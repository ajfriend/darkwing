[
  {
    "objectID": "trips_analysis.html",
    "href": "trips_analysis.html",
    "title": "NYC Trips Example Analysis",
    "section": "",
    "text": "We’ll use the NYC Taxi data set to demonstrate analyzing data interactively with Darkwing. We’ll compare Taxi trip fares by pickup location between January and February 2010.\nWe discretize locations into hexagonal bins with H3. One of the benefits of using DuckDB directly, is that we can use anything from the DuckDB ecosystem, like its H3 extension.\n\n\nLoading data\nFirst, load a table from a local Parquet file and preview its contents.\n\nimport darkwing as dw\nt1 = dw.Table('data/yellow_tripdata_2010-01.parquet')\nt2 = dw.Table('data/yellow_tripdata_2010-02.parquet')\nt1.do('limit 7')\n\n┌───────────┬─────────────────────┬─────────────────────┬─────────────────┬────────────────────┬────────────────────┬─────────────────┬───────────┬────────────────────┬────────────────────┬──────────────────┬──────────────┬─────────────┬───────────┬─────────┬────────────┬──────────────┬──────────────┐\n│ vendor_id │   pickup_datetime   │  dropoff_datetime   │ passenger_count │   trip_distance    │  pickup_longitude  │ pickup_latitude │ rate_code │ store_and_fwd_flag │ dropoff_longitude  │ dropoff_latitude │ payment_type │ fare_amount │ surcharge │ mta_tax │ tip_amount │ tolls_amount │ total_amount │\n│  varchar  │       varchar       │       varchar       │      int64      │       double       │       double       │     double      │  varchar  │      varchar       │       double       │      double      │   varchar    │   double    │  double   │ double  │   double   │    double    │    double    │\n├───────────┼─────────────────────┼─────────────────────┼─────────────────┼────────────────────┼────────────────────┼─────────────────┼───────────┼────────────────────┼────────────────────┼──────────────────┼──────────────┼─────────────┼───────────┼─────────┼────────────┼──────────────┼──────────────┤\n│ VTS       │ 2010-01-26 07:41:00 │ 2010-01-26 07:45:00 │               1 │               0.75 │         -73.956778 │        40.76775 │ 1         │ NULL               │         -73.965957 │        40.765232 │ CAS          │         4.5 │       0.0 │     0.5 │        0.0 │          0.0 │          5.0 │\n│ DDS       │ 2010-01-30 23:31:00 │ 2010-01-30 23:46:12 │               1 │                5.9 │ -73.99611799999998 │       40.763932 │ 1         │ NULL               │ -73.98151199999998 │        40.741193 │ CAS          │        15.3 │       0.5 │     0.5 │        0.0 │          0.0 │         16.3 │\n│ DDS       │ 2010-01-18 20:22:20 │ 2010-01-18 20:38:12 │               1 │                4.0 │         -73.979673 │        40.78379 │ 1         │ NULL               │ -73.91785199999998 │         40.87856 │ CAS          │        11.7 │       0.5 │     0.5 │        0.0 │          0.0 │         12.7 │\n│ VTS       │ 2010-01-09 01:18:00 │ 2010-01-09 01:35:00 │               2 │                4.7 │         -73.977922 │       40.763997 │ 1         │ NULL               │ -73.92390799999998 │        40.759725 │ CAS          │        13.3 │       0.5 │     0.5 │        0.0 │          0.0 │         14.3 │\n│ CMT       │ 2010-01-18 19:10:14 │ 2010-01-18 19:17:07 │               1 │ 0.5999999999999999 │         -73.990924 │       40.734682 │ 1         │ 0                  │ -73.99551099999998 │        40.739088 │ Cre          │         5.3 │       0.0 │     0.5 │       0.87 │          0.0 │         6.67 │\n│ DDS       │ 2010-01-23 18:40:25 │ 2010-01-23 18:54:51 │               1 │                3.3 │                0.0 │             0.0 │ 1         │ NULL               │                0.0 │              0.0 │ CRE          │        10.5 │       0.0 │     0.5 │        1.0 │          0.0 │         12.0 │\n│ VTS       │ 2010-01-17 09:18:00 │ 2010-01-17 09:25:00 │               1 │               1.33 │         -73.993747 │       40.754917 │ 1         │ NULL               │ -73.98471499999998 │        40.755927 │ CAS          │         6.1 │       0.0 │     0.5 │        0.0 │          0.0 │          6.6 │\n└───────────┴─────────────────────┴─────────────────────┴─────────────────┴────────────────────┴────────────────────┴─────────────────┴───────────┴────────────────────┴────────────────────┴──────────────────┴──────────────┴─────────────┴───────────┴─────────┴────────────┴──────────────┴──────────────┘\n\n\nWe can get a list of columns with t1.columns.\n\nt1.columns\n\n['vendor_id',\n 'pickup_datetime',\n 'dropoff_datetime',\n 'passenger_count',\n 'trip_distance',\n 'pickup_longitude',\n 'pickup_latitude',\n 'rate_code',\n 'store_and_fwd_flag',\n 'dropoff_longitude',\n 'dropoff_latitude',\n 'payment_type',\n 'fare_amount',\n 'surcharge',\n 'mta_tax',\n 'tip_amount',\n 'tolls_amount',\n 'total_amount']\n\n\n\n\nInspecting and transforming data interactively\nYou can run one or more SQL expressions with the Table.do() method.\nExpressions are in standard DuckDB SQL, with some small changes:\n\nfrom &lt;table_name&gt; is automatically inserted into the expression for you.\nselect ... is optional; if omitted, select * will be inserted.\n\nWe’ll see a few examples of what we can do below.\nConvert pickup latitude/longitude locations to resolution 8 H3 cells. Resolution 8 cells are about 0.7 km^2 in size.\n\nx = t1.do(\"\"\"\nselect\n    *,\n    h3_latlng_to_cell(pickup_latitude, pickup_longitude, 8)\n        as hexid,\n\"\"\")\nx.do('limit 2')\n\n┌───────────┬─────────────────────┬─────────────────────┬─────────────────┬───────────────┬────────────────────┬─────────────────┬───────────┬────────────────────┬────────────────────┬──────────────────┬──────────────┬─────────────┬───────────┬─────────┬────────────┬──────────────┬──────────────┬────────────────────┐\n│ vendor_id │   pickup_datetime   │  dropoff_datetime   │ passenger_count │ trip_distance │  pickup_longitude  │ pickup_latitude │ rate_code │ store_and_fwd_flag │ dropoff_longitude  │ dropoff_latitude │ payment_type │ fare_amount │ surcharge │ mta_tax │ tip_amount │ tolls_amount │ total_amount │       hexid        │\n│  varchar  │       varchar       │       varchar       │      int64      │    double     │       double       │     double      │  varchar  │      varchar       │       double       │      double      │   varchar    │   double    │  double   │ double  │   double   │    double    │    double    │       uint64       │\n├───────────┼─────────────────────┼─────────────────────┼─────────────────┼───────────────┼────────────────────┼─────────────────┼───────────┼────────────────────┼────────────────────┼──────────────────┼──────────────┼─────────────┼───────────┼─────────┼────────────┼──────────────┼──────────────┼────────────────────┤\n│ VTS       │ 2010-01-26 07:41:00 │ 2010-01-26 07:45:00 │               1 │          0.75 │         -73.956778 │        40.76775 │ 1         │ NULL               │         -73.965957 │        40.765232 │ CAS          │         4.5 │       0.0 │     0.5 │        0.0 │          0.0 │          5.0 │ 613229522950553599 │\n│ DDS       │ 2010-01-30 23:31:00 │ 2010-01-30 23:46:12 │               1 │           5.9 │ -73.99611799999998 │       40.763932 │ 1         │ NULL               │ -73.98151199999998 │        40.741193 │ CAS          │        15.3 │       0.5 │     0.5 │        0.0 │          0.0 │         16.3 │ 613229551343894527 │\n└───────────┴─────────────────────┴─────────────────────┴─────────────────┴───────────────┴────────────────────┴─────────────────┴───────────┴────────────────────┴────────────────────┴──────────────────┴──────────────┴─────────────┴───────────┴─────────┴────────────┴──────────────┴──────────────┴────────────────────┘\n\n\nCompute the average of total_amount for each H3 cell, along with the number of trips:\n\nx = x.do(\"\"\"\nselect\n    hexid,\n    avg(total_amount) \n        as amount,\n    count(*)\n        as num,\ngroup by\n    1\n\"\"\")\nx.do('limit 2')\n\n┌────────────────────┬───────────────────┬────────┐\n│       hexid        │      amount       │  num   │\n│       uint64       │      double       │ int64  │\n├────────────────────┼───────────────────┼────────┤\n│ 613229522992496639 │ 9.670524807010345 │ 288487 │\n│ 613229524244496383 │ 10.81630906718967 │ 666127 │\n└────────────────────┴───────────────────┴────────┘\n\n\nConvert the H3 cell id to its hexadecimal representation:\n\nx = x.do(\"\"\"\nselect\n    h3_h3_to_string(hexid)\n        as hexid,\n    amount,\n    num,\n\"\"\")\nx.do('limit 2')\n\n┌─────────────────┬────────────────────┬────────┐\n│      hexid      │       amount       │  num   │\n│     varchar     │       double       │ int64  │\n├─────────────────┼────────────────────┼────────┤\n│ 882a1008bbfffff │   9.67052480701034 │ 288487 │\n│ 882a100d65fffff │ 10.816309067189671 │ 666127 │\n└─────────────────┴────────────────────┴────────┘\n\n\n\n\nGrouping transforms with lists and functions\nNote that Table.do() also accepts a sequence of strings, so you could write all of the previous steps with a single function call.\n\nt1.do(\n    'select *, h3_latlng_to_cell(pickup_latitude, pickup_longitude, 8) as hexid',\n    'select hexid, avg(total_amount) as amount, count(*) as num group by 1',\n    'select h3_h3_to_string(hexid) as hexid, amount, num',\n    'limit 5'\n)\n\n┌─────────────────┬────────────────────┬────────┐\n│      hexid      │       amount       │  num   │\n│     varchar     │       double       │ int64  │\n├─────────────────┼────────────────────┼────────┤\n│ 882a100893fffff │   9.66153303243029 │ 426051 │\n│ 882a10725bfffff │ 10.288604039526431 │ 421287 │\n│ 882a100883fffff │  9.985855459480879 │ 222512 │\n│ 882a10089bfffff │  10.68603411867983 │ 252882 │\n│ 882a1072c7fffff │ 11.649603050363377 │ 203779 │\n└─────────────────┴────────────────────┴────────┘\n\n\nTo help organize things, we can collect a sequence of steps as a list of strings.\n\navg_list = [\n    'select *, h3_latlng_to_cell(pickup_latitude, pickup_longitude, 8) as hexid',\n    'select hexid, avg(total_amount) as amount, count(*) as num group by 1',\n    'select h3_h3_to_string(hexid) as hexid, amount, num',\n]\n\nWe can apply the sequence of steps in avg_list to table t1 in multiple ways. If Table.do() encounters a list, it will apply each element of the list in sequence recursively, which means each of the following are equivalent:\n\nt1.do(*avg_list)\nt1.do(avg_list)\nt1.do([avg_list])\nt1.do([[avg_list]])\n\nWe can also wrap operations in a Python function, which Table.do() can also handle.\n\ndef avg_func(tbl):\n    \"\"\"\n    tbl: [pickup_latitude, pickup_longitude, total_amount]\n    returns: [hexid, amount, num]\n    \"\"\"\n    return tbl.do(avg_list)\n\nThe following are equivalent:\n\navg_func(t1)\nt1.do(avg_func)\nt1.do([avg_func])\n\nWe can build up complex nested expressions by combining functions, query strings, and lists, so the following are equivalent:\n\nt1.do(avg_func, 'where num &gt; 100')\nt1.do(avg_list, 'where num &gt; 100')\nt1.do([avg_func, 'where num &gt; 100'])\nt1.do([avg_list, 'where num &gt; 100'])\n\n\n\nExploration and filtering\nExploring the data, we notice there are many trips in February that have zero or negative fare. We’ll want to filter those out.\n\nt2.do(\"\"\"\nselect\n    total_amount &gt; 0,\n    count(*),\ngroup by\n    1\n\"\"\")\n\n┌────────────────────┬──────────────┐\n│ (total_amount &gt; 0) │ count_star() │\n│      boolean       │    int64     │\n├────────────────────┼──────────────┤\n│ true               │     11133961 │\n│ false              │        11448 │\n└────────────────────┴──────────────┘\n\n\nWe also spot many trips where the lat/lng is erroneously listed as (0,0):\n\nt1.do(\"\"\"\nselect\n    (pickup_longitude = 0) or (pickup_latitude = 0),\n    count(*),\ngroup by\n    1\n\"\"\")\n\n┌───────────────────────────────────────────────────┬──────────────┐\n│ ((pickup_longitude = 0) OR (pickup_latitude = 0)) │ count_star() │\n│                      boolean                      │    int64     │\n├───────────────────────────────────────────────────┼──────────────┤\n│ true                                              │       268338 │\n│ false                                             │     14595440 │\n└───────────────────────────────────────────────────┴──────────────┘\n\n\nAfter aggregating, we also notice there are lots of hexes with only a few trips. Let’s say we’ll only look at hexes with at least 100 trips.\n\nt1.do(\n    avg_func,\n    \"\"\"\n    select\n        cast(log10(num)+1 as int)\n            as num_digits,\n        count(*),\n    group by 1\n    order by 1\n    \"\"\"\n)\n\n┌────────────┬──────────────┐\n│ num_digits │ count_star() │\n│   int32    │    int64     │\n├────────────┼──────────────┤\n│          1 │         5907 │\n│          2 │         1784 │\n│          3 │          619 │\n│          4 │          165 │\n│          5 │           58 │\n│          6 │           43 │\n│          7 │           18 │\n└────────────┴──────────────┘\n\n\n\n\nJoins\nWe want to compute average fares for hexes and compare them across January and February. We compute the averages like above, but also want to exlude hexes with only a few trips. So we extend the data pipeline to filter out such hexes, and apply the same operation to the datasets for each month.\n\nt1 = dw.Table('data/yellow_tripdata_2010-01.parquet')\nt2 = dw.Table('data/yellow_tripdata_2010-02.parquet')\n\nf = [\n    'where (pickup_longitude != 0) and (pickup_latitude != 0)',\n    'where total_amount &gt; 0',\n    avg_list,\n    'where num &gt; 100',\n]\n\nt1 = t1.do(f)\nt2 = t2.do(f)\n\nt2\n\n┌─────────────────┬────────────────────┬────────┐\n│      hexid      │       amount       │  num   │\n│     varchar     │       double       │ int64  │\n├─────────────────┼────────────────────┼────────┤\n│ 882a100d21fffff │    9.8002849642464 │ 394646 │\n│ 882a100d3dfffff │ 10.678114470973194 │  33004 │\n│ 882a100de5fffff │ 13.483709288299154 │   3316 │\n│ 882a10088bfffff │ 10.239837104266105 │  46717 │\n│ 882a100d25fffff │  9.672628073222125 │ 252219 │\n│ 882a107293fffff │ 14.064174557900744 │   8765 │\n│ 882a100f25fffff │ 12.872607298166006 │   5289 │\n│ 882a107259fffff │ 10.764344060885385 │  75289 │\n│ 882a100d51fffff │ 13.020678205248789 │  10631 │\n│ 882a100e25fffff │ 31.516969143024358 │  54704 │\n│        ·        │          ·         │     ·  │\n│        ·        │          ·         │     ·  │\n│        ·        │          ·         │     ·  │\n│ 882a107283fffff │ 12.298571428571432 │    175 │\n│ 882a100f0dfffff │ 10.365704225352113 │    142 │\n│ 882a100f61fffff │ 14.980888888888886 │    180 │\n│ 882a1008abfffff │ 13.244495798319328 │    238 │\n│ 882a107621fffff │ 11.883454545454546 │    110 │\n│ 882a107737fffff │ 12.570526315789474 │    114 │\n│ 882a100131fffff │ 15.255344827586207 │    116 │\n│ 882a1072dbfffff │ 10.858313253012048 │    166 │\n│ 882a10745dfffff │ 12.909618320610686 │    131 │\n│ 882a107535fffff │ 10.693010204081633 │    196 │\n├─────────────────┴────────────────────┴────────┤\n│ 444 rows (20 shown)                 3 columns │\n└───────────────────────────────────────────────┘\n\n\nTo perform a join, you need two tables in on place. In Darkwing, such a place is a Database.\n\ndb = dw.Database(t1=t1, t2=t2)\n\n\ndb['t1']\n\n┌─────────────────┬────────────────────┬────────┐\n│      hexid      │       amount       │  num   │\n│     varchar     │       double       │ int64  │\n├─────────────────┼────────────────────┼────────┤\n│ 882a100d2dfffff │ 10.063673290722761 │ 702490 │\n│ 882a100d63fffff │ 10.330906250848717 │ 515354 │\n│ 882a1072cbfffff │ 11.197824274511566 │ 310894 │\n│ 882a100d27fffff │  9.670567800006804 │ 436615 │\n│ 882a1008dbfffff │  11.44080308628559 │   9202 │\n│ 882a100c67fffff │   13.1571773906861 │   2813 │\n│ 882a100da1fffff │ 12.614583253128005 │   5195 │\n│ 882a100d47fffff │ 11.340621336459552 │   2559 │\n│ 882a10724bfffff │ 13.894047151277011 │    509 │\n│ 882a1008d1fffff │ 11.119358472086192 │  14294 │\n│        ·        │          ·         │     ·  │\n│        ·        │          ·         │     ·  │\n│        ·        │          ·         │     ·  │\n│ 882a1008ebfffff │  11.71502538071066 │    197 │\n│ 882a103b47fffff │  26.62735294117647 │    204 │\n│ 882a10775dfffff │ 11.509371727748691 │    191 │\n│ 882a100acdfffff │ 11.756525423728814 │    118 │\n│ 882a100f55fffff │  12.77540740740741 │    135 │\n│ 882a107247fffff │  16.27857142857143 │    308 │\n│ 882a107207fffff │ 16.860051282051284 │    195 │\n│ 882a1008a9fffff │ 13.725797872340427 │    188 │\n│ 882a10762dfffff │ 14.620600000000001 │    150 │\n│ 882a107295fffff │ 10.917304347826088 │    115 │\n├─────────────────┴────────────────────┴────────┤\n│ 504 rows (20 shown)                 3 columns │\n└───────────────────────────────────────────────┘\n\n\n\n# but note that because evaluation is lazy, it will recompute each time.\n# If you want to avoid that, you can materialize the computation and create a new database. Note there is no need to do this if you don't mind recomputing.\n\n\ndb = db.hold()\n\n\ndb\n\nDatabase:\n    t1: 504 x ['hexid', 'amount', 'num']\n    t2: 444 x ['hexid', 'amount', 'num']\n\n\n\n# NOTE: maybe confusing to users who now see a new view of their table...\n# I wonder if caching the relation, or making it a property is the way to go...\n# TODO: how to unify the representation between Table and a table in a Database? And reveal the underlying representation (string, df, arrow, etc.)\ndb.do('from t1')\n\n┌─────────────────┬────────────────────┬────────┐\n│      hexid      │       amount       │  num   │\n│     varchar     │       double       │ int64  │\n├─────────────────┼────────────────────┼────────┤\n│ 882a100d65fffff │  10.81630906718967 │ 666127 │\n│ 882a100d45fffff │ 10.594611812368376 │ 185619 │\n│ 882a107299fffff │  14.28901087356201 │  38074 │\n│ 882a100897fffff │  8.755456601197544 │ 140626 │\n│ 882a1008bbfffff │   9.67052480701034 │ 288487 │\n│ 882a100f57fffff │ 28.707747238240927 │  71965 │\n│ 882a100e8dfffff │ 13.623135135135136 │    185 │\n│ 882a100889fffff │ 11.282130774389216 │ 105877 │\n│ 882a1008c3fffff │  12.25155796770957 │  43852 │\n│ 882a100da7fffff │ 12.546433862433862 │  15120 │\n│        ·        │          ·         │     ·  │\n│        ·        │          ·         │     ·  │\n│        ·        │          ·         │     ·  │\n│ 882a100a99fffff │ 10.584477611940297 │    134 │\n│ 882a10762dfffff │ 14.620600000000001 │    150 │\n│ 882a100abbfffff │ 10.905583126550868 │    403 │\n│ 882a1008a9fffff │ 13.725797872340424 │    188 │\n│ 882a100f45fffff │ 10.899663865546218 │    119 │\n│ 882a107207fffff │ 16.860051282051284 │    195 │\n│ 882a100f55fffff │ 12.775407407407407 │    135 │\n│ 88754e64d3fffff │         10.3846875 │    192 │\n│ 882a107247fffff │  16.27857142857143 │    308 │\n│ 882a107731fffff │ 13.234427480916029 │    131 │\n├─────────────────┴────────────────────┴────────┤\n│ 504 rows (20 shown)                 3 columns │\n└───────────────────────────────────────────────┘\n\n\n\n# You can execute duckdb sql on a database, but now you should explicitly mention the table you want to work with (but that's usually what you want anyway, when doing a join.)\n\n\nout = db.do(\"\"\"\nselect\n      hexid\n    , t1.amount\n        as fare_jan\n    , t2.amount\n        as fare_feb\nfrom\n    t1\ninner join\n    t2\nusing\n    (hexid)\n\"\"\").do(\"\"\"\nselect\n      *\n    , fare_feb - fare_jan\n        as fare_change\norder by\n    fare_change\n\"\"\")\nout\n\n┌─────────────────┬────────────────────┬────────────────────┬─────────────────────┐\n│      hexid      │      fare_jan      │      fare_feb      │     fare_change     │\n│     varchar     │       double       │       double       │       double        │\n├─────────────────┼────────────────────┼────────────────────┼─────────────────────┤\n│ 882a1071adfffff │  69.73084615384614 │ 58.737914798206276 │ -10.992931355639868 │\n│ 882a100c01fffff │ 27.110503597122307 │ 20.741372549019605 │  -6.369131048102702 │\n│ 882a100e37fffff │   33.0306355140187 │  28.06555765595463 │  -4.965077858064067 │\n│ 882a1072e7fffff │ 42.255209580838326 │  38.42423076923077 │  -3.830978811607558 │\n│ 882a1008e9fffff │ 17.742466666666665 │ 14.009843750000002 │ -3.7326229166666636 │\n│ 882a1008e7fffff │  14.85293233082707 │ 11.121284403669726 │ -3.7316479271573435 │\n│ 882a107207fffff │ 16.860051282051284 │ 13.165116279069768 │ -3.6949350029815164 │\n│ 882a100e85fffff │ 29.665849999999995 │  26.64545454545455 │ -3.0203954545454437 │\n│ 882a100cc1fffff │ 18.814318181818184 │  15.84008695652174 │ -2.9742312252964442 │\n│ 882a10705bfffff │  25.10495283018868 │ 22.228385650224215 │ -2.8765671799644643 │\n│        ·        │          ·         │          ·         │           ·         │\n│        ·        │          ·         │          ·         │           ·         │\n│        ·        │          ·         │          ·         │           ·         │\n│ 882a10723bfffff │  36.69252998909488 │ 42.577538896746816 │   5.885008907651937 │\n│ 882a1072e3fffff │ 22.588899676375405 │ 28.593956521739123 │   6.005056845363718 │\n│ 882a107239fffff │  30.49176237623762 │ 36.845988023952096 │   6.354225647714475 │\n│ 882a107231fffff │  25.71543147208122 │  33.13404255319149 │   7.418611081110271 │\n│ 882a103b61fffff │ 38.679219251336896 │  46.58243243243243 │   7.903213181095531 │\n│ 882a100ee5fffff │ 13.650664869721473 │ 21.770178571428573 │     8.1195137017071 │\n│ 882a107209fffff │ 16.478663594470046 │ 24.767259036144576 │    8.28859544167453 │\n│ 882a100813fffff │ 16.437430167597768 │ 25.611982758620687 │    9.17455259102292 │\n│ 882a100d03fffff │ 12.004190371991244 │ 21.602025227750527 │   9.597834855759283 │\n│ 882a100ebbfffff │  39.36631964809386 │  53.30473029045642 │  13.938410642362562 │\n├─────────────────┴────────────────────┴────────────────────┴─────────────────────┤\n│ 426 rows (20 shown)                                                   4 columns │\n└─────────────────────────────────────────────────────────────────────────────────┘\n\n\n\nimport matplotlib.pyplot as plt\n\ndf = out.df()\n\nfig, ax = plt.subplots()\nax.plot([0,70], [0,70], color='k', linestyle='--')\ndf.plot.scatter(x='fare_jan', y='fare_feb', alpha=.6, ax=ax)\nplt.grid()\n\n\n\n\n\n\n\n\n\n\nEnd-to-end example\n\nimport darkwing as dw\n\ncore = [\n    'select *, h3_latlng_to_cell(pickup_latitude, pickup_longitude, 8) as hexid',\n    'select hexid, avg(total_amount) as amount, count(*) as num group by 1',\n    'select h3_h3_to_string(hexid) as hexid, amount, num',\n]\n\ncore_with_filters = [\n    'where (pickup_longitude != 0) and (pickup_latitude != 0)',\n    'where total_amount &gt; 0',\n    core,\n    'where num &gt; 100',\n]\n\ndb = dw.Database(\n    t1 = dw.Table('data/yellow_tripdata_2010-01.parquet').do(core_with_filters),\n    t2 = dw.Table('data/yellow_tripdata_2010-02.parquet').do(core_with_filters),\n)\n\ndb.do(\"\"\"\n    select\n        hexid,\n        t1.amount  as  fare_jan,\n        t2.amount  as  fare_feb,\n    from        t1\n    inner join  t2\n    using       (hexid)\n\"\"\",\n    'select *, fare_feb - fare_jan as fare_change',\n    'order by fare_change',\n)\n\n┌─────────────────┬────────────────────┬────────────────────┬─────────────────────┐\n│      hexid      │      fare_jan      │      fare_feb      │     fare_change     │\n│     varchar     │       double       │       double       │       double        │\n├─────────────────┼────────────────────┼────────────────────┼─────────────────────┤\n│ 882a1071adfffff │  69.73084615384614 │ 58.737914798206276 │ -10.992931355639868 │\n│ 882a100c01fffff │ 27.110503597122303 │  20.74137254901961 │  -6.369131048102695 │\n│ 882a100e37fffff │  33.03063551401869 │  28.06555765595463 │   -4.96507785806406 │\n│ 882a1072e7fffff │  42.25520958083833 │  38.42423076923076 │ -3.8309788116075723 │\n│ 882a1008e9fffff │ 17.742466666666665 │ 14.009843750000002 │ -3.7326229166666636 │\n│ 882a1008e7fffff │ 14.852932330827068 │ 11.121284403669726 │ -3.7316479271573417 │\n│ 882a107207fffff │ 16.860051282051284 │ 13.165116279069766 │ -3.6949350029815182 │\n│ 882a100e85fffff │ 29.665849999999992 │ 26.645454545454545 │ -3.0203954545454472 │\n│ 882a100cc1fffff │ 18.814318181818184 │  15.84008695652174 │ -2.9742312252964442 │\n│ 882a10705bfffff │  25.10495283018868 │ 22.228385650224215 │ -2.8765671799644643 │\n│        ·        │          ·         │          ·         │           ·         │\n│        ·        │          ·         │          ·         │           ·         │\n│        ·        │          ·         │          ·         │           ·         │\n│ 882a10723bfffff │  36.69252998909488 │ 42.577538896746816 │   5.885008907651937 │\n│ 882a1072e3fffff │ 22.588899676375405 │ 28.593956521739123 │   6.005056845363718 │\n│ 882a107239fffff │  30.49176237623762 │ 36.845988023952096 │   6.354225647714475 │\n│ 882a107231fffff │  25.71543147208122 │  33.13404255319149 │   7.418611081110271 │\n│ 882a103b61fffff │ 38.679219251336896 │  46.58243243243243 │   7.903213181095531 │\n│ 882a100ee5fffff │ 13.650664869721474 │ 21.770178571428573 │   8.119513701707099 │\n│ 882a107209fffff │ 16.478663594470046 │ 24.767259036144576 │    8.28859544167453 │\n│ 882a100813fffff │ 16.437430167597768 │  25.61198275862069 │   9.174552591022923 │\n│ 882a100d03fffff │ 12.004190371991244 │  21.60202522775052 │   9.597834855759276 │\n│ 882a100ebbfffff │  39.36631964809386 │  53.30473029045642 │  13.938410642362562 │\n├─────────────────┴────────────────────┴────────────────────┴─────────────────────┤\n│ 426 rows (20 shown)                                                   4 columns │\n└─────────────────────────────────────────────────────────────────────────────────┘",
    "crumbs": [
      "NYC Trips Example Analysis"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "darkwing",
    "section": "",
    "text": "Darkwing is a work-in-progress “dataframe library” that I use in personal interactive data analysis projects. (I use quotes because it’s really just a light wrapper around the DuckDB relational API.)\nYou can concatenate SQL snippets (often omitting select * and from ...) to incrementally build up complex queries. Expressions are evaluated lazily and optimized by DuckDB, so queries are fast, without the need for intermediate tables or data transfers.\nThis approach results in a mixture of Python and SQL that, I think, is semantically very similar to Google’s Pipe Syntax for SQL: We can leverage our existing knowledge of SQL, while making a few small changes to make it more ergonomic and composable.\nWhen doing interactive data analysis, I find this approach easier to read and write than fluent APIs (like in Polars or Ibis) or typical Pandas code. If some operation is easier in other libraries, Darking makes it straightforward translate between them, either directly or through Apache Arrow.\nI’d love to hear any feedback on the approach here, so feel free to reach out through Issues or Discussions.\n\n\npip install git+https://github.com/ajfriend/darkwing\n\n\n\nimport darkwing as dw\n\n# read from a remote CSV file\ntbl = dw.Table('https://raw.githubusercontent.com/mcnakhaee/palmerpenguins/refs/heads/master/palmerpenguins/data/penguins.csv')\ntbl = dw.Table('data/penguins.csv')  # read from a local CSV file\n\ndf = tbl.df()  # write to Pandas DataFrame\ndw.Table(df)  # read from Pandas DataFrame\n\ndf.to_parquet('data/penguins.parquet')  # use Pandas to write to a Parquet file\ntbl = dw.Table('data/penguins.parquet')  # read from a local Parquet file\n\ntbl_arrow = tbl.arrow()  # write to an  Arrow Table\ntbl = dw.Table(tbl_arrow)  # read from an Arrow Table\n\n\n\nThe library revolves around two objects and a function: Database, Table.\n\nDatabase is essentially a dictionary mapping names to objects that will get resolved to tables. Those objects might be a Pandas or Polars dataframe, a PyArrow Table, the local filename of a Parquet or CSV file, or a URL to a remote data file. These objects are used by darkwing and Duckdb lazily, so operations on them are deffered until a final result is requested.\nTable is a wrapper around a DuckDB Relation.\n\n\n\n\nSince all operations are done through DuckDBPyRelation, the expressions are evaluated lazily, or only at the end when we want a table or want to display results to the console.\nIf you would like to materialze a Table or a Database concretely in terms of Pandas DataFrames or PyArrow Tables, you can use x.hold(kind='arrow') or x.do('arrow').\nWhen you materialize a Database you can access the underlying tables with db[table_name].\n\n\n\n\n\ndarkwing uses DuckDB to build up Relation expressions through chaining, which DuckDB will then execute after running the entire expression through a query planner to optimize execution.\nimport darkwing as dw\n\n# dw.Table('https://d37ci6vzurychx.cloudfront.net/trip-data/yellow_tripdata_2010-01.parquet')\ndw.Table('yellow_tripdata_2010-01.parquet').do(\n    'select *, pickup_latitude as lat, pickup_longitude as lng',\n    'select *, h3_latlng_to_cell(lat, lng, 8) as hexid',\n    'select hexid, avg(tip_amount) as tip  group by 1',\n    'select h3_h3_to_string(hexid) as hexid, tip',\n    'where tip between 10 and 20',\n    'order by hexid',\n)\nGives the output:\n┌─────────────────┬────────────────────┐\n│      hexid      │        tip         │\n│     varchar     │       double       │\n├─────────────────┼────────────────────┤\n│ 881bb2a0b5fffff │              12.22 │\n│ 882a100299fffff │  10.02818181818182 │\n│ 882a10029dfffff │ 11.666666666666666 │\n│ 882a1002c3fffff │               10.0 │\n│ 882a10034bfffff │               16.0 │\n│ 882a100353fffff │               17.6 │\n│ 882a10045bfffff │               10.0 │\n│ 882a100487fffff │             11.525 │\n│ 882a10060dfffff │               16.1 │\n│ 882a100611fffff │               10.0 │\n│        ·        │                 ·  │\n│        ·        │                 ·  │\n│        ·        │                 ·  │\n│ 882a13c4d9fffff │               11.5 │\n│ 882a13d281fffff │               20.0 │\n│ 882a13d529fffff │               15.0 │\n│ 882a1438c3fffff │               10.0 │\n│ 882a15663bfffff │               10.0 │\n│ 882a1ab9c1fffff │              10.01 │\n│ 882a353927fffff │              11.05 │\n│ 882aa16327fffff │              12.51 │\n│ 882aaab9ebfffff │              10.01 │\n│ 882ad09327fffff │              12.51 │\n├─────────────────┴────────────────────┤\n│ 193 rows (20 shown)        2 columns │\n└──────────────────────────────────────┘\n\n\nYou can also write the above as\ndw.Table('data/yellow_tripdata_2010-01.parquet').do(\n    'select *, pickup_latitude as lat, pickup_longitude as lng',\n    'select *, h3_latlng_to_cell(lat, lng, 8) as hexid',\n    'select hexid, avg(tip_amount) as tip  group by 1',\n    'select h3_h3_to_string(hexid) as hexid, tip',\n    'where tip between 10 and 20',\n    'order by hexid',\n)\nor\ndw.Table('data/yellow_tripdata_2010-01.parquet').do(\n    'select *, pickup_latitude as lat, pickup_longitude as lng',\n).do(\n    'select *, h3_latlng_to_cell(lat, lng, 8) as hexid',\n).do(\n    'select hexid, avg(tip_amount) as tip  group by 1',\n).do(\n    'select h3_h3_to_string(hexid) as hexid, tip',\n).do(\n   'where tip between 10 and 20',\n).do(\n    'order by hexid',\n)\n\n\n\n\nTODO\n\n\n\nYou might store a sequence of steps as a function like\ndef foo(rel, res=6):\n    return (rel\n    | 'select pickup_latitude as lat, pickup_longitude as lng, tip_amount'       \n    | f'select h3_latlng_to_cell(lat, lng, {res}) as hexid, tip_amount as tip'\n    | 'select hexid, avg(tip) as tip group by 1'\n    | 'select h3_h3_to_string(hexid) as hexid, tip'\n    | 'where tip &gt; 0'\n    )\nwhich you could apply with any of the following syntax:\n\ntable.do(foo)\ntable | foo or table &gt;&gt; foo\n\nAlternatively, you could store this as a sequence of strings:\nfoo_list = [\n    'select pickup_latitude as lat, pickup_longitude as lng, tip_amount'       \n    'select h3_latlng_to_cell(lat, lng, 6}) as hexid, tip_amount as tip'\n    'select hexid, avg(tip) as tip group by 1'\n    'select h3_h3_to_string(hexid) as hexid, tip'\n    'where tip &gt; 0'\n]\nwhich you could apply with something like\ntable.do(*foo_list)\nor\ntable.do(foo_list)\nor even\ntable | foo_list",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#installing",
    "href": "index.html#installing",
    "title": "darkwing",
    "section": "",
    "text": "pip install git+https://github.com/ajfriend/darkwing",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#loading-saving-and-transferring-tables",
    "href": "index.html#loading-saving-and-transferring-tables",
    "title": "darkwing",
    "section": "",
    "text": "import darkwing as dw\n\n# read from a remote CSV file\ntbl = dw.Table('https://raw.githubusercontent.com/mcnakhaee/palmerpenguins/refs/heads/master/palmerpenguins/data/penguins.csv')\ntbl = dw.Table('data/penguins.csv')  # read from a local CSV file\n\ndf = tbl.df()  # write to Pandas DataFrame\ndw.Table(df)  # read from Pandas DataFrame\n\ndf.to_parquet('data/penguins.parquet')  # use Pandas to write to a Parquet file\ntbl = dw.Table('data/penguins.parquet')  # read from a local Parquet file\n\ntbl_arrow = tbl.arrow()  # write to an  Arrow Table\ntbl = dw.Table(tbl_arrow)  # read from an Arrow Table",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#databases-and-tables",
    "href": "index.html#databases-and-tables",
    "title": "darkwing",
    "section": "",
    "text": "The library revolves around two objects and a function: Database, Table.\n\nDatabase is essentially a dictionary mapping names to objects that will get resolved to tables. Those objects might be a Pandas or Polars dataframe, a PyArrow Table, the local filename of a Parquet or CSV file, or a URL to a remote data file. These objects are used by darkwing and Duckdb lazily, so operations on them are deffered until a final result is requested.\nTable is a wrapper around a DuckDB Relation.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#laziness",
    "href": "index.html#laziness",
    "title": "darkwing",
    "section": "",
    "text": "Since all operations are done through DuckDBPyRelation, the expressions are evaluated lazily, or only at the end when we want a table or want to display results to the console.\nIf you would like to materialze a Table or a Database concretely in terms of Pandas DataFrames or PyArrow Tables, you can use x.hold(kind='arrow') or x.do('arrow').\nWhen you materialize a Database you can access the underlying tables with db[table_name].",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#examples",
    "href": "index.html#examples",
    "title": "darkwing",
    "section": "",
    "text": "darkwing uses DuckDB to build up Relation expressions through chaining, which DuckDB will then execute after running the entire expression through a query planner to optimize execution.\nimport darkwing as dw\n\n# dw.Table('https://d37ci6vzurychx.cloudfront.net/trip-data/yellow_tripdata_2010-01.parquet')\ndw.Table('yellow_tripdata_2010-01.parquet').do(\n    'select *, pickup_latitude as lat, pickup_longitude as lng',\n    'select *, h3_latlng_to_cell(lat, lng, 8) as hexid',\n    'select hexid, avg(tip_amount) as tip  group by 1',\n    'select h3_h3_to_string(hexid) as hexid, tip',\n    'where tip between 10 and 20',\n    'order by hexid',\n)\nGives the output:\n┌─────────────────┬────────────────────┐\n│      hexid      │        tip         │\n│     varchar     │       double       │\n├─────────────────┼────────────────────┤\n│ 881bb2a0b5fffff │              12.22 │\n│ 882a100299fffff │  10.02818181818182 │\n│ 882a10029dfffff │ 11.666666666666666 │\n│ 882a1002c3fffff │               10.0 │\n│ 882a10034bfffff │               16.0 │\n│ 882a100353fffff │               17.6 │\n│ 882a10045bfffff │               10.0 │\n│ 882a100487fffff │             11.525 │\n│ 882a10060dfffff │               16.1 │\n│ 882a100611fffff │               10.0 │\n│        ·        │                 ·  │\n│        ·        │                 ·  │\n│        ·        │                 ·  │\n│ 882a13c4d9fffff │               11.5 │\n│ 882a13d281fffff │               20.0 │\n│ 882a13d529fffff │               15.0 │\n│ 882a1438c3fffff │               10.0 │\n│ 882a15663bfffff │               10.0 │\n│ 882a1ab9c1fffff │              10.01 │\n│ 882a353927fffff │              11.05 │\n│ 882aa16327fffff │              12.51 │\n│ 882aaab9ebfffff │              10.01 │\n│ 882ad09327fffff │              12.51 │\n├─────────────────┴────────────────────┤\n│ 193 rows (20 shown)        2 columns │\n└──────────────────────────────────────┘\n\n\nYou can also write the above as\ndw.Table('data/yellow_tripdata_2010-01.parquet').do(\n    'select *, pickup_latitude as lat, pickup_longitude as lng',\n    'select *, h3_latlng_to_cell(lat, lng, 8) as hexid',\n    'select hexid, avg(tip_amount) as tip  group by 1',\n    'select h3_h3_to_string(hexid) as hexid, tip',\n    'where tip between 10 and 20',\n    'order by hexid',\n)\nor\ndw.Table('data/yellow_tripdata_2010-01.parquet').do(\n    'select *, pickup_latitude as lat, pickup_longitude as lng',\n).do(\n    'select *, h3_latlng_to_cell(lat, lng, 8) as hexid',\n).do(\n    'select hexid, avg(tip_amount) as tip  group by 1',\n).do(\n    'select h3_h3_to_string(hexid) as hexid, tip',\n).do(\n   'where tip between 10 and 20',\n).do(\n    'order by hexid',\n)\n\n\n\n\nTODO\n\n\n\nYou might store a sequence of steps as a function like\ndef foo(rel, res=6):\n    return (rel\n    | 'select pickup_latitude as lat, pickup_longitude as lng, tip_amount'       \n    | f'select h3_latlng_to_cell(lat, lng, {res}) as hexid, tip_amount as tip'\n    | 'select hexid, avg(tip) as tip group by 1'\n    | 'select h3_h3_to_string(hexid) as hexid, tip'\n    | 'where tip &gt; 0'\n    )\nwhich you could apply with any of the following syntax:\n\ntable.do(foo)\ntable | foo or table &gt;&gt; foo\n\nAlternatively, you could store this as a sequence of strings:\nfoo_list = [\n    'select pickup_latitude as lat, pickup_longitude as lng, tip_amount'       \n    'select h3_latlng_to_cell(lat, lng, 6}) as hexid, tip_amount as tip'\n    'select hexid, avg(tip) as tip group by 1'\n    'select h3_h3_to_string(hexid) as hexid, tip'\n    'where tip &gt; 0'\n]\nwhich you could apply with something like\ntable.do(*foo_list)\nor\ntable.do(foo_list)\nor even\ntable | foo_list",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#piping",
    "href": "index.html#piping",
    "title": "darkwing",
    "section": "Piping",
    "text": "Piping\nYou can use both | and &gt;&gt; to pipe SQL snippets and some other operations. Be careful When mixing | and &gt;&gt;, and note the operator precedence rules. Note you can always use parenthesis to specify evaluation order, or build up expressions in a fluent style like a.sql(s1).sql(s2).\nthese are equivalent to .do(), which can also take in a multiple arguments.\nFor example:\n\na | b maps to a.sql(b) when a is a Database or Table and b is a query string\na &gt;&gt; f resolves to f(a) if f is a callable\n\nIn the “use whichever form is most horrifying to your peers” syntax category, we have: - 'filename.parquet' &gt;&gt; dw.Table is the same as dw.Table('filename.parquet'). - a &gt;&gt; 'as table_name' resolves to a Database(table_name = a) - a &gt;&gt; list - a &gt;&gt; dict - a &gt;&gt; int - a &gt;&gt; float - a &gt;&gt; str - a &gt;&gt; bool - a &gt;&gt; pd.DataFrame",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "darkwing",
    "section": "References",
    "text": "References\n\nPRQL\nDuckDB’s SQL improvements",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#whats-different-from-duckdbs-relational-api",
    "href": "index.html#whats-different-from-duckdbs-relational-api",
    "title": "darkwing",
    "section": "What’s different from DuckDB’s relational api",
    "text": "What’s different from DuckDB’s relational api\n\navoid connection objects",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "duckdb_stuff.html",
    "href": "duckdb_stuff.html",
    "title": "Relevant DuckDB Concepts and Features",
    "section": "",
    "text": "darkwing is primarily built on DuckDB’s Relational API. As an escape hatch, darkwing exposes its DuckDB compoents for you to use directly:\n\nhttps://duckdb.org/docs/api/python/reference/#duckdb.DuckDBPyConnection.install_extension\nhttps://duckdb.org/docs/api/python/reference/#duckdb.DuckDBPyRelation.columns\n\nTODO: does that simplify my columns helper!?\n\nhttps://duckdb.org/docs/api/python/reference/#duckdb.DuckDBPyRelation.describe\nhttps://duckdb.org/docs/api/python/reference/#duckdb.DuckDBPyRelation.description\nhttps://duckdb.org/docs/api/python/reference/#duckdb.DuckDBPyRelation.dtypes\nexplain\nexecute\n\nTODO: actually, what does this do?\n\nhttps://duckdb.org/docs/api/python/reference/#duckdb.DuckDBPyRelation.query\nhttps://duckdb.org/docs/api/python/reference/#duckdb.DuckDBPyRelation.show\nhttps://duckdb.org/docs/api/python/reference/#duckdb.DuckDBPyRelation.sql_query\nhttps://duckdb.org/docs/api/python/reference/#duckdb.DuckDBPyRelation.shape\nhttps://duckdb.org/docs/api/python/reference/#duckdb.DuckDBPyRelation.histogram\n\nTODO: what’s the SQL for this, would make for a good example\n\nhttps://duckdb.org/docs/api/python/reference/#duckdb.DuckDBPyRelation.type\nhttps://duckdb.org/docs/api/python/reference/#duckdb.DuckDBPyRelation.types\nhttps://duckdb.org/docs/api/python/reference/#duckdb.ExplainType",
    "crumbs": [
      "Relevant DuckDB Concepts and Features"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "now with justfile!",
    "crumbs": [
      "About"
    ]
  }
]