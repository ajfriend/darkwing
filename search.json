[
  {
    "objectID": "lazy.html",
    "href": "lazy.html",
    "title": "Lazy Evaluation",
    "section": "",
    "text": "Since darkwing builds on top of DuckDB’s relational API, all expressions are lazily evaluated by default. This means that complex query expressions can be built up interactively and step by step, and when you are ready to evaluate the final expression (or any intermediate expressions), the query steps will be assembed and optimized by the query planner to allow for the most efficient execuation possible:\n\navoid materialzing intermediate tables\nSQL pushdown optimizations\nDuckDB streaming and out-of-core operations\n\n\nGotchas\n\ninteractive analysis that calls a repr or str method, like having a table be the last expression in a Jupyter notebook cell\nIDEs that inspect variables proactively will call the repr on objects, which will trigger query evaluation. this happens in Positron, for example\n\n\n\nExample",
    "crumbs": [
      "Lazy Evaluation"
    ]
  },
  {
    "objectID": "ramble.html",
    "href": "ramble.html",
    "title": "AJ Rambles",
    "section": "",
    "text": "darkwing excels at simple, readable interactive work without new syntax\nother libraries excel at providing IDE support and type hinting.\nI’m not a user of the latter, so I’m less familiar with the benefits here. However, I am interested in understanding if there is a way to capture the benefits of each of these approaches.\nWhat would a best-of-both-worlds library/language look like?\nas i said, this library is experimental. i’m going hard in one direction as a way to explore the developer experience space. I’m also interested in using this project as a way to kick off discussions of how to build future libraries and languages to solve similar problems.",
    "crumbs": [
      "AJ Rambles"
    ]
  },
  {
    "objectID": "ramble.html#repr",
    "href": "ramble.html#repr",
    "title": "AJ Rambles",
    "section": "Repr",
    "text": "Repr\nmaybe provide a repr option to provide an alternative to avoid the computation Table('.../...', repr='bah'). Should it pass it down to derived objects? Maybe that’s too complicated",
    "crumbs": [
      "AJ Rambles"
    ]
  },
  {
    "objectID": "ramble.html#opener",
    "href": "ramble.html#opener",
    "title": "AJ Rambles",
    "section": "Opener",
    "text": "Opener\nAn alternative Python DataFrame library for SQL gremlins.\n\nyou think SQL is fine, especially if you can write composable snippets\nmaybe you lose some IDE and typing support, but I think you get a big win in terms of REPL/notebook programming (which is where i spend most of my time)\n\nor, an experiment in https://en.wiktionary.org/wiki/Cunningham%27s_Law",
    "crumbs": [
      "AJ Rambles"
    ]
  },
  {
    "objectID": "tut_nyc_join.html",
    "href": "tut_nyc_join.html",
    "title": "NYC Trips Example Analysis",
    "section": "",
    "text": "We’ll use the NYC Taxi data set to demonstrate analyzing data interactively with Darkwing. We’ll compare Taxi trip fares by pickup location between January and February 2010.\nWe discretize locations into hexagonal bins with H3. One of the benefits of using DuckDB directly, is that we can use anything from the DuckDB ecosystem, like its H3 extension.\n\n\nLoading data\nFirst, load a table from a local Parquet file and preview its contents.\n\nimport darkwing as dw\nt1 = dw.Table('data/yellow_tripdata_2010-01.parquet')\nt2 = dw.Table('data/yellow_tripdata_2010-02.parquet')\nt1.do('limit 7')\n\n┌───────────┬─────────────────────┬─────────────────────┬─────────────────┬────────────────────┬────────────────────┬─────────────────┬───────────┬────────────────────┬────────────────────┬──────────────────┬──────────────┬─────────────┬───────────┬─────────┬────────────┬──────────────┬──────────────┐\n│ vendor_id │   pickup_datetime   │  dropoff_datetime   │ passenger_count │   trip_distance    │  pickup_longitude  │ pickup_latitude │ rate_code │ store_and_fwd_flag │ dropoff_longitude  │ dropoff_latitude │ payment_type │ fare_amount │ surcharge │ mta_tax │ tip_amount │ tolls_amount │ total_amount │\n│  varchar  │       varchar       │       varchar       │      int64      │       double       │       double       │     double      │  varchar  │      varchar       │       double       │      double      │   varchar    │   double    │  double   │ double  │   double   │    double    │    double    │\n├───────────┼─────────────────────┼─────────────────────┼─────────────────┼────────────────────┼────────────────────┼─────────────────┼───────────┼────────────────────┼────────────────────┼──────────────────┼──────────────┼─────────────┼───────────┼─────────┼────────────┼──────────────┼──────────────┤\n│ VTS       │ 2010-01-26 07:41:00 │ 2010-01-26 07:45:00 │               1 │               0.75 │         -73.956778 │        40.76775 │ 1         │ NULL               │         -73.965957 │        40.765232 │ CAS          │         4.5 │       0.0 │     0.5 │        0.0 │          0.0 │          5.0 │\n│ DDS       │ 2010-01-30 23:31:00 │ 2010-01-30 23:46:12 │               1 │                5.9 │ -73.99611799999998 │       40.763932 │ 1         │ NULL               │ -73.98151199999998 │        40.741193 │ CAS          │        15.3 │       0.5 │     0.5 │        0.0 │          0.0 │         16.3 │\n│ DDS       │ 2010-01-18 20:22:20 │ 2010-01-18 20:38:12 │               1 │                4.0 │         -73.979673 │        40.78379 │ 1         │ NULL               │ -73.91785199999998 │         40.87856 │ CAS          │        11.7 │       0.5 │     0.5 │        0.0 │          0.0 │         12.7 │\n│ VTS       │ 2010-01-09 01:18:00 │ 2010-01-09 01:35:00 │               2 │                4.7 │         -73.977922 │       40.763997 │ 1         │ NULL               │ -73.92390799999998 │        40.759725 │ CAS          │        13.3 │       0.5 │     0.5 │        0.0 │          0.0 │         14.3 │\n│ CMT       │ 2010-01-18 19:10:14 │ 2010-01-18 19:17:07 │               1 │ 0.5999999999999999 │         -73.990924 │       40.734682 │ 1         │ 0                  │ -73.99551099999998 │        40.739088 │ Cre          │         5.3 │       0.0 │     0.5 │       0.87 │          0.0 │         6.67 │\n│ DDS       │ 2010-01-23 18:40:25 │ 2010-01-23 18:54:51 │               1 │                3.3 │                0.0 │             0.0 │ 1         │ NULL               │                0.0 │              0.0 │ CRE          │        10.5 │       0.0 │     0.5 │        1.0 │          0.0 │         12.0 │\n│ VTS       │ 2010-01-17 09:18:00 │ 2010-01-17 09:25:00 │               1 │               1.33 │         -73.993747 │       40.754917 │ 1         │ NULL               │ -73.98471499999998 │        40.755927 │ CAS          │         6.1 │       0.0 │     0.5 │        0.0 │          0.0 │          6.6 │\n└───────────┴─────────────────────┴─────────────────────┴─────────────────┴────────────────────┴────────────────────┴─────────────────┴───────────┴────────────────────┴────────────────────┴──────────────────┴──────────────┴─────────────┴───────────┴─────────┴────────────┴──────────────┴──────────────┘\n\n\nWe can get a list of columns with t1.columns.\n\nt1.columns\n\n['vendor_id',\n 'pickup_datetime',\n 'dropoff_datetime',\n 'passenger_count',\n 'trip_distance',\n 'pickup_longitude',\n 'pickup_latitude',\n 'rate_code',\n 'store_and_fwd_flag',\n 'dropoff_longitude',\n 'dropoff_latitude',\n 'payment_type',\n 'fare_amount',\n 'surcharge',\n 'mta_tax',\n 'tip_amount',\n 'tolls_amount',\n 'total_amount']\n\n\n\n\nInspecting and transforming data interactively\nYou can run one or more SQL expressions with the Table.do() method.\nExpressions are in standard DuckDB SQL, with some small changes:\n\nfrom &lt;table_name&gt; is automatically inserted into the expression for you.\nselect ... is optional; if omitted, select * will be inserted.\n\nWe’ll see a few examples of what we can do below.\nConvert pickup latitude/longitude locations to resolution 8 H3 cells. Resolution 8 cells are about 0.7 km^2 in size.\n\nx = t1.do(\"\"\"\nselect\n    *,\n    h3_latlng_to_cell(pickup_latitude, pickup_longitude, 8)\n        as hexid,\n\"\"\")\nx.do('limit 2')\n\n┌───────────┬─────────────────────┬─────────────────────┬─────────────────┬───────────────┬────────────────────┬─────────────────┬───────────┬────────────────────┬────────────────────┬──────────────────┬──────────────┬─────────────┬───────────┬─────────┬────────────┬──────────────┬──────────────┬────────────────────┐\n│ vendor_id │   pickup_datetime   │  dropoff_datetime   │ passenger_count │ trip_distance │  pickup_longitude  │ pickup_latitude │ rate_code │ store_and_fwd_flag │ dropoff_longitude  │ dropoff_latitude │ payment_type │ fare_amount │ surcharge │ mta_tax │ tip_amount │ tolls_amount │ total_amount │       hexid        │\n│  varchar  │       varchar       │       varchar       │      int64      │    double     │       double       │     double      │  varchar  │      varchar       │       double       │      double      │   varchar    │   double    │  double   │ double  │   double   │    double    │    double    │       uint64       │\n├───────────┼─────────────────────┼─────────────────────┼─────────────────┼───────────────┼────────────────────┼─────────────────┼───────────┼────────────────────┼────────────────────┼──────────────────┼──────────────┼─────────────┼───────────┼─────────┼────────────┼──────────────┼──────────────┼────────────────────┤\n│ VTS       │ 2010-01-26 07:41:00 │ 2010-01-26 07:45:00 │               1 │          0.75 │         -73.956778 │        40.76775 │ 1         │ NULL               │         -73.965957 │        40.765232 │ CAS          │         4.5 │       0.0 │     0.5 │        0.0 │          0.0 │          5.0 │ 613229522950553599 │\n│ DDS       │ 2010-01-30 23:31:00 │ 2010-01-30 23:46:12 │               1 │           5.9 │ -73.99611799999998 │       40.763932 │ 1         │ NULL               │ -73.98151199999998 │        40.741193 │ CAS          │        15.3 │       0.5 │     0.5 │        0.0 │          0.0 │         16.3 │ 613229551343894527 │\n└───────────┴─────────────────────┴─────────────────────┴─────────────────┴───────────────┴────────────────────┴─────────────────┴───────────┴────────────────────┴────────────────────┴──────────────────┴──────────────┴─────────────┴───────────┴─────────┴────────────┴──────────────┴──────────────┴────────────────────┘\n\n\nCompute the average of total_amount for each H3 cell, along with the number of trips:\n\nx = x.do(\"\"\"\nselect\n    hexid,\n    avg(total_amount) \n        as amount,\n    count(*)\n        as num,\ngroup by\n    1\n\"\"\")\nx.do('limit 2')\n\n┌────────────────────┬───────────────────┬────────┐\n│       hexid        │      amount       │  num   │\n│       uint64       │      double       │ int64  │\n├────────────────────┼───────────────────┼────────┤\n│ 613229524181581823 │  9.82921158914791 │ 504610 │\n│ 613229522990399487 │ 9.775451726322807 │ 224118 │\n└────────────────────┴───────────────────┴────────┘\n\n\nConvert the H3 cell id to its hexadecimal representation:\n\nx = x.do(\"\"\"\nselect\n    h3_h3_to_string(hexid)\n        as hexid,\n    amount,\n    num,\n\"\"\")\nx.do('limit 2')\n\n┌─────────────────┬────────────────────┬────────┐\n│      hexid      │       amount       │  num   │\n│     varchar     │       double       │ int64  │\n├─────────────────┼────────────────────┼────────┤\n│ 882a100893fffff │   9.66153303243029 │ 426051 │\n│ 882a10725bfffff │ 10.288604039526431 │ 421287 │\n└─────────────────┴────────────────────┴────────┘\n\n\n\n\nGrouping transforms with lists and functions\nNote that Table.do() also accepts a sequence of strings, so you could write all of the previous steps with a single function call.\n\nt1.do(\n    'select *, h3_latlng_to_cell(pickup_latitude, pickup_longitude, 8) as hexid',\n    'select hexid, avg(total_amount) as amount, count(*) as num group by 1',\n    'select h3_h3_to_string(hexid) as hexid, amount, num',\n    'limit 5'\n)\n\n┌─────────────────┬────────────────────┬────────┐\n│      hexid      │       amount       │  num   │\n│     varchar     │       double       │ int64  │\n├─────────────────┼────────────────────┼────────┤\n│ 882a100893fffff │   9.66153303243029 │ 426051 │\n│ 882a10725bfffff │ 10.288604039526431 │ 421287 │\n│ 882a1072c9fffff │ 10.324864870461475 │ 386333 │\n│ 882a1072c7fffff │ 11.649603050363378 │ 203779 │\n│ 882a1072c3fffff │ 11.387625279142473 │  89560 │\n└─────────────────┴────────────────────┴────────┘\n\n\nTo help organize things, we can collect a sequence of steps as a list of strings.\n\navg_list = [\n    'select *, h3_latlng_to_cell(pickup_latitude, pickup_longitude, 8) as hexid',\n    'select hexid, avg(total_amount) as amount, count(*) as num group by 1',\n    'select h3_h3_to_string(hexid) as hexid, amount, num',\n]\n\nWe can apply the sequence of steps in avg_list to table t1 in multiple ways. If Table.do() encounters a list, it will apply each element of the list in sequence recursively, which means each of the following are equivalent:\n\nt1.do(*avg_list)\nt1.do(avg_list)\nt1.do([avg_list])\nt1.do([[avg_list]])\n\nWe can also wrap operations in a Python function, which Table.do() can also handle.\n\ndef avg_func(tbl):\n    \"\"\"\n    tbl: [pickup_latitude, pickup_longitude, total_amount]\n    returns: [hexid, amount, num]\n    \"\"\"\n    return tbl.do(avg_list)\n\nThe following are equivalent:\n\navg_func(t1)\nt1.do(avg_func)\nt1.do([avg_func])\n\nWe can build up complex nested expressions by combining functions, query strings, and lists, so the following are equivalent:\n\nt1.do(avg_func, 'where num &gt; 100')\nt1.do(avg_list, 'where num &gt; 100')\nt1.do([avg_func, 'where num &gt; 100'])\nt1.do([avg_list, 'where num &gt; 100'])\n\n\n\nExploration and filtering\nExploring the data, we notice there are many trips in February that have zero or negative fare. We’ll want to filter those out.\n\nt2.do(\"\"\"\nselect\n    total_amount &gt; 0,\n    count(*),\ngroup by\n    1\n\"\"\")\n\n┌────────────────────┬──────────────┐\n│ (total_amount &gt; 0) │ count_star() │\n│      boolean       │    int64     │\n├────────────────────┼──────────────┤\n│ false              │        11448 │\n│ true               │     11133961 │\n└────────────────────┴──────────────┘\n\n\nWe also spot many trips where the lat/lng is erroneously listed as (0,0):\n\nt1.do(\"\"\"\nselect\n    (pickup_longitude = 0) or (pickup_latitude = 0),\n    count(*),\ngroup by\n    1\n\"\"\")\n\n┌───────────────────────────────────────────────────┬──────────────┐\n│ ((pickup_longitude = 0) OR (pickup_latitude = 0)) │ count_star() │\n│                      boolean                      │    int64     │\n├───────────────────────────────────────────────────┼──────────────┤\n│ false                                             │     14595440 │\n│ true                                              │       268338 │\n└───────────────────────────────────────────────────┴──────────────┘\n\n\nAfter aggregating, we also notice there are lots of hexes with only a few trips. Let’s say we’ll only look at hexes with at least 100 trips.\n\nt1.do(\n    avg_func,\n    \"\"\"\n    select\n        cast(log10(num)+1 as int)\n            as num_digits,\n        count(*),\n    group by 1\n    order by 1\n    \"\"\"\n)\n\n┌────────────┬──────────────┐\n│ num_digits │ count_star() │\n│   int32    │    int64     │\n├────────────┼──────────────┤\n│          1 │         5907 │\n│          2 │         1784 │\n│          3 │          619 │\n│          4 │          165 │\n│          5 │           58 │\n│          6 │           43 │\n│          7 │           18 │\n└────────────┴──────────────┘\n\n\n\n\nJoins\nWe want to compute average fares for hexes and compare them across January and February. We compute the averages like above, but also want to exlude hexes with only a few trips. So we extend the data pipeline to filter out such hexes, and apply the same operation to the datasets for each month.\n\nt1 = dw.Table('data/yellow_tripdata_2010-01.parquet')\nt2 = dw.Table('data/yellow_tripdata_2010-02.parquet')\n\nf = [\n    'where (pickup_longitude != 0) and (pickup_latitude != 0)',\n    'where total_amount &gt; 0',\n    avg_list,\n    'where num &gt; 100',\n]\n\nt1 = t1.do(f)\nt2 = t2.do(f)\n\nt2\n\n┌─────────────────┬────────────────────┬────────┐\n│      hexid      │       amount       │  num   │\n│     varchar     │       double       │ int64  │\n├─────────────────┼────────────────────┼────────┤\n│ 882a1008d9fffff │ 11.059448705224215 │  11083 │\n│ 882a100899fffff │ 10.411548308382274 │ 151630 │\n│ 882a10725bfffff │ 10.571474829685698 │ 320437 │\n│ 882a100883fffff │ 10.157081830180402 │ 159110 │\n│ 882a10089bfffff │ 10.793596658617215 │ 177651 │\n│ 882a100893fffff │  9.707957632905174 │ 307550 │\n│ 882a1072c9fffff │ 10.412091727564057 │ 294895 │\n│ 882a1072c7fffff │ 11.857230505352101 │ 157415 │\n│ 882a10728bfffff │ 15.447922427616254 │  33053 │\n│ 882a107281fffff │ 14.905988703724397 │  53646 │\n│        ·        │          ·         │     ·  │\n│        ·        │          ·         │     ·  │\n│        ·        │          ·         │     ·  │\n│ 882a100abdfffff │  11.92628252788104 │    269 │\n│ 882a107207fffff │ 13.165116279069768 │    172 │\n│ 882a107731fffff │ 11.568877551020408 │    196 │\n│ 882a100aadfffff │ 14.958499999999997 │    160 │\n│ 882a1008e3fffff │  20.56820143884892 │    139 │\n│ 882a100ed1fffff │ 12.962890995260663 │    211 │\n│ 882a1008ebfffff │ 12.131242236024846 │    161 │\n│ 882a100c29fffff │ 15.441469194312795 │    211 │\n│ 882a100f55fffff │ 11.017017543859648 │    114 │\n│ 88754e64d3fffff │ 12.981250000000005 │    168 │\n├─────────────────┴────────────────────┴────────┤\n│ 444 rows (20 shown)                 3 columns │\n└───────────────────────────────────────────────┘\n\n\nTo perform a join, you need two tables in on place. In Darkwing, such a place is a Database.\n\ndb = dw.Database(t1=t1, t2=t2)\n\n\ndb['t1']\n\n┌─────────────────┬────────────────────┬────────┐\n│      hexid      │       amount       │  num   │\n│     varchar     │       double       │ int64  │\n├─────────────────┼────────────────────┼────────┤\n│ 882a100d65fffff │  10.81630906718967 │ 666127 │\n│ 882a100d45fffff │ 10.594611812368376 │ 185619 │\n│ 882a107299fffff │ 14.289010873562015 │  38074 │\n│ 882a100897fffff │  8.755456601197542 │ 140626 │\n│ 882a1008bbfffff │  9.670524807010343 │ 288487 │\n│ 882a100f57fffff │  28.70774723824092 │  71965 │\n│ 882a100e8dfffff │ 13.623135135135135 │    185 │\n│ 882a100889fffff │ 11.282130774389216 │ 105877 │\n│ 882a1008c3fffff │ 12.251557967709573 │  43852 │\n│ 882a100da7fffff │ 12.546433862433863 │  15120 │\n│        ·        │          ·         │     ·  │\n│        ·        │          ·         │     ·  │\n│        ·        │          ·         │     ·  │\n│ 882a100a99fffff │ 10.584477611940297 │    134 │\n│ 882a10762dfffff │ 14.620599999999998 │    150 │\n│ 882a100abbfffff │ 10.905583126550868 │    403 │\n│ 882a1008a9fffff │ 13.725797872340424 │    188 │\n│ 882a100f45fffff │ 10.899663865546218 │    119 │\n│ 882a107207fffff │ 16.860051282051284 │    195 │\n│ 882a100f55fffff │ 12.775407407407409 │    135 │\n│ 88754e64d3fffff │         10.3846875 │    192 │\n│ 882a107247fffff │ 16.278571428571425 │    308 │\n│ 882a107731fffff │  13.23442748091603 │    131 │\n├─────────────────┴────────────────────┴────────┤\n│ 504 rows (20 shown)                 3 columns │\n└───────────────────────────────────────────────┘\n\n\n\n# but note that because evaluation is lazy, it will recompute each time.\n# If you want to avoid that, you can materialize the computation and create a new database. Note there is no need to do this if you don't mind recomputing.\n\n\ndb = db.hold()\n\n\ndb\n\nDatabase:\n    t1: 504 x ['hexid', 'amount', 'num']\n    t2: 444 x ['hexid', 'amount', 'num']\n\n\n\n# NOTE: maybe confusing to users who now see a new view of their table...\n# I wonder if caching the relation, or making it a property is the way to go...\n# TODO: how to unify the representation between Table and a table in a Database? And reveal the underlying representation (string, df, arrow, etc.)\ndb.do('from t1')\n\n┌─────────────────┬────────────────────┬────────┐\n│      hexid      │       amount       │  num   │\n│     varchar     │       double       │ int64  │\n├─────────────────┼────────────────────┼────────┤\n│ 882a100d6dfffff │   9.79461901059728 │ 142773 │\n│ 882a100d4dfffff │ 10.477939382011419 │  71134 │\n│ 882a107219fffff │  10.43954911679714 │ 104506 │\n│ 882a100895fffff │   9.83854816036588 │ 106706 │\n│ 882a1008b3fffff │  9.949875167611046 │ 346785 │\n│ 882a10721bfffff │ 10.650209316209915 │ 308194 │\n│ 882a1072ddfffff │ 11.091350516373895 │  22658 │\n│ 882a103b1dfffff │ 39.663308764407496 │  59696 │\n│ 882a100aa9fffff │ 17.609217144881335 │   5646 │\n│ 882a100f65fffff │  18.20959505061867 │    889 │\n│        ·        │          ·         │     ·  │\n│        ·        │          ·         │     ·  │\n│        ·        │          ·         │     ·  │\n│ 882a100dbbfffff │ 13.068114285714286 │    175 │\n│ 882a100c07fffff │ 11.367704918032787 │    122 │\n│ 882a10771dfffff │  9.959941176470588 │    170 │\n│ 882a100e3bfffff │ 13.195209713024282 │    453 │\n│ 882a100ed5fffff │ 11.569121951219515 │    205 │\n│ 882a107055fffff │ 22.933666666666667 │    120 │\n│ 882a107269fffff │ 15.572254901960783 │    102 │\n│ 882a100e17fffff │ 12.087846153846153 │    130 │\n│ 882a100c27fffff │ 11.392851063829788 │    235 │\n│ 882a10744dfffff │ 11.827341040462427 │    173 │\n├─────────────────┴────────────────────┴────────┤\n│ 504 rows (20 shown)                 3 columns │\n└───────────────────────────────────────────────┘\n\n\n\n# You can execute duckdb sql on a database, but now you should explicitly mention the table you want to work with (but that's usually what you want anyway, when doing a join.)\n\n\nout = db.do(\"\"\"\nselect\n      hexid\n    , t1.amount\n        as fare_jan\n    , t2.amount\n        as fare_feb\nfrom\n    t1\ninner join\n    t2\nusing\n    (hexid)\n\"\"\").do(\"\"\"\nselect\n      *\n    , fare_feb - fare_jan\n        as fare_change\norder by\n    fare_change\n\"\"\")\nout\n\n┌─────────────────┬────────────────────┬────────────────────┬─────────────────────┐\n│      hexid      │      fare_jan      │      fare_feb      │     fare_change     │\n│     varchar     │       double       │       double       │       double        │\n├─────────────────┼────────────────────┼────────────────────┼─────────────────────┤\n│ 882a1071adfffff │  69.73084615384616 │  58.73791479820627 │  -10.99293135563989 │\n│ 882a100c01fffff │ 27.110503597122303 │ 20.741372549019605 │  -6.369131048102698 │\n│ 882a100e37fffff │  33.03063551401869 │ 28.065557655954635 │  -4.965077858064056 │\n│ 882a1072e7fffff │ 42.255209580838326 │  38.42423076923076 │  -3.830978811607565 │\n│ 882a1008e9fffff │ 17.742466666666665 │        14.00984375 │ -3.7326229166666653 │\n│ 882a1008e7fffff │ 14.852932330827068 │ 11.121284403669723 │ -3.7316479271573453 │\n│ 882a107207fffff │ 16.860051282051284 │ 13.165116279069768 │ -3.6949350029815164 │\n│ 882a100e85fffff │           29.66585 │ 26.645454545454545 │ -3.0203954545454543 │\n│ 882a100cc1fffff │  18.81431818181818 │  15.84008695652174 │ -2.9742312252964407 │\n│ 882a10705bfffff │ 25.104952830188683 │ 22.228385650224215 │  -2.876567179964468 │\n│        ·        │          ·         │          ·         │           ·         │\n│        ·        │          ·         │          ·         │           ·         │\n│        ·        │          ·         │          ·         │           ·         │\n│ 882a10723bfffff │  36.69252998909488 │ 42.577538896746816 │   5.885008907651937 │\n│ 882a1072e3fffff │ 22.588899676375405 │ 28.593956521739134 │   6.005056845363729 │\n│ 882a107239fffff │ 30.491762376237624 │   36.8459880239521 │   6.354225647714479 │\n│ 882a107231fffff │  25.71543147208122 │ 33.134042553191485 │   7.418611081110264 │\n│ 882a103b61fffff │ 38.679219251336896 │ 46.582432432432434 │   7.903213181095538 │\n│ 882a100ee5fffff │ 13.650664869721474 │ 21.770178571428573 │   8.119513701707099 │\n│ 882a107209fffff │ 16.478663594470046 │ 24.767259036144576 │    8.28859544167453 │\n│ 882a100813fffff │ 16.437430167597768 │ 25.611982758620687 │    9.17455259102292 │\n│ 882a100d03fffff │ 12.004190371991243 │ 21.602025227750524 │   9.597834855759281 │\n│ 882a100ebbfffff │  39.36631964809386 │  53.30473029045642 │  13.938410642362562 │\n├─────────────────┴────────────────────┴────────────────────┴─────────────────────┤\n│ 426 rows (20 shown)                                                   4 columns │\n└─────────────────────────────────────────────────────────────────────────────────┘\n\n\n\nimport matplotlib.pyplot as plt\n\ndf = out.df()\n\nfig, ax = plt.subplots()\nax.plot([0,70], [0,70], color='k', linestyle='--')\ndf.plot.scatter(x='fare_jan', y='fare_feb', alpha=.6, ax=ax)\nplt.grid()\n\n\n\n\n\n\n\n\n\n\nEnd-to-end example\n\nimport darkwing as dw\n\ncore = [\n    'select *, h3_latlng_to_cell(pickup_latitude, pickup_longitude, 8) as hexid',\n    'select hexid, avg(total_amount) as amount, count(*) as num group by 1',\n    'select h3_h3_to_string(hexid) as hexid, amount, num',\n]\n\ncore_with_filters = [\n    'where (pickup_longitude != 0) and (pickup_latitude != 0)',\n    'where total_amount &gt; 0',\n    core,\n    'where num &gt; 100',\n]\n\ndb = dw.Database(\n    t1 = dw.Table('data/yellow_tripdata_2010-01.parquet').do(core_with_filters),\n    t2 = dw.Table('data/yellow_tripdata_2010-02.parquet').do(core_with_filters),\n)\n\ndb.do(\"\"\"\n    select\n        hexid,\n        t1.amount  as  fare_jan,\n        t2.amount  as  fare_feb,\n    from        t1\n    inner join  t2\n    using       (hexid)\n\"\"\",\n    'select *, fare_feb - fare_jan as fare_change',\n    'order by fare_change',\n)\n\n┌─────────────────┬────────────────────┬────────────────────┬─────────────────────┐\n│      hexid      │      fare_jan      │      fare_feb      │     fare_change     │\n│     varchar     │       double       │       double       │       double        │\n├─────────────────┼────────────────────┼────────────────────┼─────────────────────┤\n│ 882a1071adfffff │  69.73084615384616 │  58.73791479820627 │  -10.99293135563989 │\n│ 882a100c01fffff │ 27.110503597122303 │ 20.741372549019605 │  -6.369131048102698 │\n│ 882a100e37fffff │  33.03063551401869 │ 28.065557655954635 │  -4.965077858064056 │\n│ 882a1072e7fffff │  42.25520958083832 │  38.42423076923077 │  -3.830978811607551 │\n│ 882a1008e9fffff │ 17.742466666666665 │ 14.009843749999998 │  -3.732622916666667 │\n│ 882a1008e7fffff │ 14.852932330827068 │ 11.121284403669726 │ -3.7316479271573417 │\n│ 882a107207fffff │ 16.860051282051284 │ 13.165116279069768 │ -3.6949350029815164 │\n│ 882a100e85fffff │ 29.665849999999995 │  26.64545454545455 │ -3.0203954545454437 │\n│ 882a100cc1fffff │  18.81431818181818 │  15.84008695652174 │ -2.9742312252964407 │\n│ 882a10705bfffff │  25.10495283018868 │ 22.228385650224215 │ -2.8765671799644643 │\n│        ·        │          ·         │          ·         │           ·         │\n│        ·        │          ·         │          ·         │           ·         │\n│        ·        │          ·         │          ·         │           ·         │\n│ 882a10723bfffff │  36.69252998909488 │ 42.577538896746816 │   5.885008907651937 │\n│ 882a1072e3fffff │   22.5888996763754 │ 28.593956521739123 │   6.005056845363722 │\n│ 882a107239fffff │  30.49176237623762 │   36.8459880239521 │  6.3542256477144825 │\n│ 882a107231fffff │  25.71543147208122 │ 33.134042553191485 │   7.418611081110264 │\n│ 882a103b61fffff │ 38.679219251336896 │  46.58243243243243 │   7.903213181095531 │\n│ 882a100ee5fffff │ 13.650664869721474 │ 21.770178571428573 │   8.119513701707099 │\n│ 882a107209fffff │ 16.478663594470046 │ 24.767259036144583 │   8.288595441674538 │\n│ 882a100813fffff │ 16.437430167597768 │ 25.611982758620687 │    9.17455259102292 │\n│ 882a100d03fffff │ 12.004190371991244 │ 21.602025227750527 │   9.597834855759283 │\n│ 882a100ebbfffff │  39.36631964809386 │  53.30473029045641 │  13.938410642362555 │\n├─────────────────┴────────────────────┴────────────────────┴─────────────────────┤\n│ 426 rows (20 shown)                                                   4 columns │\n└─────────────────────────────────────────────────────────────────────────────────┘",
    "crumbs": [
      "Tutorials",
      "NYC Trips Join"
    ]
  },
  {
    "objectID": "duckdb_stuff.html",
    "href": "duckdb_stuff.html",
    "title": "DuckDB Concepts",
    "section": "",
    "text": "darkwing is primarily built on DuckDB’s Relational API. As an escape hatch, darkwing exposes its DuckDB compoents for you to use directly:\n\nhttps://duckdb.org/docs/api/python/reference/#duckdb.DuckDBPyConnection.install_extension\nhttps://duckdb.org/docs/api/python/reference/#duckdb.DuckDBPyRelation.columns\n\nTODO: does that simplify my columns helper!?\n\nhttps://duckdb.org/docs/api/python/reference/#duckdb.DuckDBPyRelation.describe\nhttps://duckdb.org/docs/api/python/reference/#duckdb.DuckDBPyRelation.description\nhttps://duckdb.org/docs/api/python/reference/#duckdb.DuckDBPyRelation.dtypes\nexplain\nexecute\n\nTODO: actually, what does this do?\n\nhttps://duckdb.org/docs/api/python/reference/#duckdb.DuckDBPyRelation.query\nhttps://duckdb.org/docs/api/python/reference/#duckdb.DuckDBPyRelation.show\nhttps://duckdb.org/docs/api/python/reference/#duckdb.DuckDBPyRelation.sql_query\nhttps://duckdb.org/docs/api/python/reference/#duckdb.DuckDBPyRelation.shape\nhttps://duckdb.org/docs/api/python/reference/#duckdb.DuckDBPyRelation.histogram\n\nTODO: what’s the SQL for this, would make for a good example\n\nhttps://duckdb.org/docs/api/python/reference/#duckdb.DuckDBPyRelation.type\nhttps://duckdb.org/docs/api/python/reference/#duckdb.DuckDBPyRelation.types\nhttps://duckdb.org/docs/api/python/reference/#duckdb.ExplainType",
    "crumbs": [
      "DuckDB Concepts"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Darkwing",
    "section": "",
    "text": "ajfriend.github.io/darkwing | github.com/ajfriend/darkwing\nDarkwing is a work-in-progress “dataframe library” that I use in personal interactive data analysis projects. (I use quotes because it’s really just a light wrapper around the DuckDB relational API.)\nYou can concatenate SQL snippets (often omitting select * and from ...) to incrementally build up complex queries. Expressions are evaluated lazily and optimized by DuckDB, so queries are fast, without the need for intermediate tables or data transfers.\nThis approach results in a mixture of Python and SQL that, I think, is semantically very similar to Google’s Pipe Syntax for SQL: We can leverage our existing knowledge of SQL, while making a few small changes to make it more ergonomic and composable.\nWhen doing interactive data analysis, I find this approach easier to read and write than fluent APIs (like in Polars or Ibis) or typical Pandas code. If some operation is easier in other libraries, Darking makes it straightforward translate between them, either directly or through Apache Arrow.\nI’d love to hear any feedback on the approach here, so feel free to reach out through Issues or Discussions.\n\n\npip install git+https://github.com/ajfriend/darkwing\n\n\n\nimport darkwing as dw\n\n# read from a remote CSV file\ntbl = dw.Table('https://raw.githubusercontent.com/mcnakhaee/palmerpenguins/refs/heads/master/palmerpenguins/data/penguins.csv')\ntbl = dw.Table('data/penguins.csv')  # read from a local CSV file\n\ndf = tbl.df()  # write to Pandas DataFrame\ndw.Table(df)  # read from Pandas DataFrame\n\ndf.to_parquet('data/penguins.parquet')  # use Pandas to write to a Parquet file\ntbl = dw.Table('data/penguins.parquet')  # read from a local Parquet file\n\ntbl_arrow = tbl.arrow()  # write to an  Arrow Table\ntbl = dw.Table(tbl_arrow)  # read from an Arrow Table\n\n\n\nThe library revolves around two objects and a function: Database, Table.\n\nDatabase is essentially a dictionary mapping names to objects that will get resolved to tables. Those objects might be a Pandas or Polars dataframe, a PyArrow Table, the local filename of a Parquet or CSV file, or a URL to a remote data file. These objects are used by darkwing and Duckdb lazily, so operations on them are deffered until a final result is requested.\nTable is a wrapper around a DuckDB Relation.\n\n\n\n\nSince all operations are done through DuckDBPyRelation, the expressions are evaluated lazily, or only at the end when we want a table or want to display results to the console.\nIf you would like to materialze a Table or a Database concretely in terms of Pandas DataFrames or PyArrow Tables, you can use x.hold(kind='arrow') or x.do('arrow').\nWhen you materialize a Database you can access the underlying tables with db[table_name].\n\n\n\n\n\ndarkwing uses DuckDB to build up Relation expressions through chaining, which DuckDB will then execute after running the entire expression through a query planner to optimize execution.\nimport darkwing as dw\n\n# dw.Table('https://d37ci6vzurychx.cloudfront.net/trip-data/yellow_tripdata_2010-01.parquet')\ndw.Table('yellow_tripdata_2010-01.parquet').do(\n    'select *, pickup_latitude as lat, pickup_longitude as lng',\n    'select *, h3_latlng_to_cell(lat, lng, 8) as hexid',\n    'select hexid, avg(tip_amount) as tip  group by 1',\n    'select h3_h3_to_string(hexid) as hexid, tip',\n    'where tip between 10 and 20',\n    'order by hexid',\n)\nGives the output:\n┌─────────────────┬────────────────────┐\n│      hexid      │        tip         │\n│     varchar     │       double       │\n├─────────────────┼────────────────────┤\n│ 881bb2a0b5fffff │              12.22 │\n│ 882a100299fffff │  10.02818181818182 │\n│ 882a10029dfffff │ 11.666666666666666 │\n│ 882a1002c3fffff │               10.0 │\n│ 882a10034bfffff │               16.0 │\n│ 882a100353fffff │               17.6 │\n│ 882a10045bfffff │               10.0 │\n│ 882a100487fffff │             11.525 │\n│ 882a10060dfffff │               16.1 │\n│ 882a100611fffff │               10.0 │\n│        ·        │                 ·  │\n│        ·        │                 ·  │\n│        ·        │                 ·  │\n│ 882a13c4d9fffff │               11.5 │\n│ 882a13d281fffff │               20.0 │\n│ 882a13d529fffff │               15.0 │\n│ 882a1438c3fffff │               10.0 │\n│ 882a15663bfffff │               10.0 │\n│ 882a1ab9c1fffff │              10.01 │\n│ 882a353927fffff │              11.05 │\n│ 882aa16327fffff │              12.51 │\n│ 882aaab9ebfffff │              10.01 │\n│ 882ad09327fffff │              12.51 │\n├─────────────────┴────────────────────┤\n│ 193 rows (20 shown)        2 columns │\n└──────────────────────────────────────┘\n\n\nYou can also write the above as\ndw.Table('data/yellow_tripdata_2010-01.parquet').do(\n    'select *, pickup_latitude as lat, pickup_longitude as lng',\n    'select *, h3_latlng_to_cell(lat, lng, 8) as hexid',\n    'select hexid, avg(tip_amount) as tip  group by 1',\n    'select h3_h3_to_string(hexid) as hexid, tip',\n    'where tip between 10 and 20',\n    'order by hexid',\n)\nor\ndw.Table('data/yellow_tripdata_2010-01.parquet').do(\n    'select *, pickup_latitude as lat, pickup_longitude as lng',\n).do(\n    'select *, h3_latlng_to_cell(lat, lng, 8) as hexid',\n).do(\n    'select hexid, avg(tip_amount) as tip  group by 1',\n).do(\n    'select h3_h3_to_string(hexid) as hexid, tip',\n).do(\n   'where tip between 10 and 20',\n).do(\n    'order by hexid',\n)\n\n\n\n\nTODO\n\n\n\nYou might store a sequence of steps as a function like\ndef foo(rel, res=6):\n    return (rel\n    | 'select pickup_latitude as lat, pickup_longitude as lng, tip_amount'       \n    | f'select h3_latlng_to_cell(lat, lng, {res}) as hexid, tip_amount as tip'\n    | 'select hexid, avg(tip) as tip group by 1'\n    | 'select h3_h3_to_string(hexid) as hexid, tip'\n    | 'where tip &gt; 0'\n    )\nwhich you could apply with any of the following syntax:\n\ntable.do(foo)\ntable | foo or table &gt;&gt; foo\n\nAlternatively, you could store this as a sequence of strings:\nfoo_list = [\n    'select pickup_latitude as lat, pickup_longitude as lng, tip_amount'       \n    'select h3_latlng_to_cell(lat, lng, 6}) as hexid, tip_amount as tip'\n    'select hexid, avg(tip) as tip group by 1'\n    'select h3_h3_to_string(hexid) as hexid, tip'\n    'where tip &gt; 0'\n]\nwhich you could apply with something like\ntable.do(*foo_list)\nor\ntable.do(foo_list)\nor even\ntable | foo_list",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#installing",
    "href": "index.html#installing",
    "title": "Darkwing",
    "section": "",
    "text": "pip install git+https://github.com/ajfriend/darkwing",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#loading-saving-and-transferring-tables",
    "href": "index.html#loading-saving-and-transferring-tables",
    "title": "Darkwing",
    "section": "",
    "text": "import darkwing as dw\n\n# read from a remote CSV file\ntbl = dw.Table('https://raw.githubusercontent.com/mcnakhaee/palmerpenguins/refs/heads/master/palmerpenguins/data/penguins.csv')\ntbl = dw.Table('data/penguins.csv')  # read from a local CSV file\n\ndf = tbl.df()  # write to Pandas DataFrame\ndw.Table(df)  # read from Pandas DataFrame\n\ndf.to_parquet('data/penguins.parquet')  # use Pandas to write to a Parquet file\ntbl = dw.Table('data/penguins.parquet')  # read from a local Parquet file\n\ntbl_arrow = tbl.arrow()  # write to an  Arrow Table\ntbl = dw.Table(tbl_arrow)  # read from an Arrow Table",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#databases-and-tables",
    "href": "index.html#databases-and-tables",
    "title": "Darkwing",
    "section": "",
    "text": "The library revolves around two objects and a function: Database, Table.\n\nDatabase is essentially a dictionary mapping names to objects that will get resolved to tables. Those objects might be a Pandas or Polars dataframe, a PyArrow Table, the local filename of a Parquet or CSV file, or a URL to a remote data file. These objects are used by darkwing and Duckdb lazily, so operations on them are deffered until a final result is requested.\nTable is a wrapper around a DuckDB Relation.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#laziness",
    "href": "index.html#laziness",
    "title": "Darkwing",
    "section": "",
    "text": "Since all operations are done through DuckDBPyRelation, the expressions are evaluated lazily, or only at the end when we want a table or want to display results to the console.\nIf you would like to materialze a Table or a Database concretely in terms of Pandas DataFrames or PyArrow Tables, you can use x.hold(kind='arrow') or x.do('arrow').\nWhen you materialize a Database you can access the underlying tables with db[table_name].",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#examples",
    "href": "index.html#examples",
    "title": "Darkwing",
    "section": "",
    "text": "darkwing uses DuckDB to build up Relation expressions through chaining, which DuckDB will then execute after running the entire expression through a query planner to optimize execution.\nimport darkwing as dw\n\n# dw.Table('https://d37ci6vzurychx.cloudfront.net/trip-data/yellow_tripdata_2010-01.parquet')\ndw.Table('yellow_tripdata_2010-01.parquet').do(\n    'select *, pickup_latitude as lat, pickup_longitude as lng',\n    'select *, h3_latlng_to_cell(lat, lng, 8) as hexid',\n    'select hexid, avg(tip_amount) as tip  group by 1',\n    'select h3_h3_to_string(hexid) as hexid, tip',\n    'where tip between 10 and 20',\n    'order by hexid',\n)\nGives the output:\n┌─────────────────┬────────────────────┐\n│      hexid      │        tip         │\n│     varchar     │       double       │\n├─────────────────┼────────────────────┤\n│ 881bb2a0b5fffff │              12.22 │\n│ 882a100299fffff │  10.02818181818182 │\n│ 882a10029dfffff │ 11.666666666666666 │\n│ 882a1002c3fffff │               10.0 │\n│ 882a10034bfffff │               16.0 │\n│ 882a100353fffff │               17.6 │\n│ 882a10045bfffff │               10.0 │\n│ 882a100487fffff │             11.525 │\n│ 882a10060dfffff │               16.1 │\n│ 882a100611fffff │               10.0 │\n│        ·        │                 ·  │\n│        ·        │                 ·  │\n│        ·        │                 ·  │\n│ 882a13c4d9fffff │               11.5 │\n│ 882a13d281fffff │               20.0 │\n│ 882a13d529fffff │               15.0 │\n│ 882a1438c3fffff │               10.0 │\n│ 882a15663bfffff │               10.0 │\n│ 882a1ab9c1fffff │              10.01 │\n│ 882a353927fffff │              11.05 │\n│ 882aa16327fffff │              12.51 │\n│ 882aaab9ebfffff │              10.01 │\n│ 882ad09327fffff │              12.51 │\n├─────────────────┴────────────────────┤\n│ 193 rows (20 shown)        2 columns │\n└──────────────────────────────────────┘\n\n\nYou can also write the above as\ndw.Table('data/yellow_tripdata_2010-01.parquet').do(\n    'select *, pickup_latitude as lat, pickup_longitude as lng',\n    'select *, h3_latlng_to_cell(lat, lng, 8) as hexid',\n    'select hexid, avg(tip_amount) as tip  group by 1',\n    'select h3_h3_to_string(hexid) as hexid, tip',\n    'where tip between 10 and 20',\n    'order by hexid',\n)\nor\ndw.Table('data/yellow_tripdata_2010-01.parquet').do(\n    'select *, pickup_latitude as lat, pickup_longitude as lng',\n).do(\n    'select *, h3_latlng_to_cell(lat, lng, 8) as hexid',\n).do(\n    'select hexid, avg(tip_amount) as tip  group by 1',\n).do(\n    'select h3_h3_to_string(hexid) as hexid, tip',\n).do(\n   'where tip between 10 and 20',\n).do(\n    'order by hexid',\n)\n\n\n\n\nTODO\n\n\n\nYou might store a sequence of steps as a function like\ndef foo(rel, res=6):\n    return (rel\n    | 'select pickup_latitude as lat, pickup_longitude as lng, tip_amount'       \n    | f'select h3_latlng_to_cell(lat, lng, {res}) as hexid, tip_amount as tip'\n    | 'select hexid, avg(tip) as tip group by 1'\n    | 'select h3_h3_to_string(hexid) as hexid, tip'\n    | 'where tip &gt; 0'\n    )\nwhich you could apply with any of the following syntax:\n\ntable.do(foo)\ntable | foo or table &gt;&gt; foo\n\nAlternatively, you could store this as a sequence of strings:\nfoo_list = [\n    'select pickup_latitude as lat, pickup_longitude as lng, tip_amount'       \n    'select h3_latlng_to_cell(lat, lng, 6}) as hexid, tip_amount as tip'\n    'select hexid, avg(tip) as tip group by 1'\n    'select h3_h3_to_string(hexid) as hexid, tip'\n    'where tip &gt; 0'\n]\nwhich you could apply with something like\ntable.do(*foo_list)\nor\ntable.do(foo_list)\nor even\ntable | foo_list",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#piping",
    "href": "index.html#piping",
    "title": "Darkwing",
    "section": "Piping",
    "text": "Piping\nYou can use both | and &gt;&gt; to pipe SQL snippets and some other operations. Be careful When mixing | and &gt;&gt;, and note the operator precedence rules. Note you can always use parenthesis to specify evaluation order, or build up expressions in a fluent style like a.sql(s1).sql(s2).\nthese are equivalent to .do(), which can also take in a multiple arguments.\nFor example:\n\na | b maps to a.sql(b) when a is a Database or Table and b is a query string\na &gt;&gt; f resolves to f(a) if f is a callable\n\nIn the “use whichever form is most horrifying to your peers” syntax category, we have: - 'filename.parquet' &gt;&gt; dw.Table is the same as dw.Table('filename.parquet'). - a &gt;&gt; 'as table_name' resolves to a Database(table_name = a) - a &gt;&gt; list - a &gt;&gt; dict - a &gt;&gt; int - a &gt;&gt; float - a &gt;&gt; str - a &gt;&gt; bool - a &gt;&gt; pd.DataFrame",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "Darkwing",
    "section": "References",
    "text": "References\n\nPRQL\nDuckDB’s SQL improvements",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#whats-different-from-duckdbs-relational-api",
    "href": "index.html#whats-different-from-duckdbs-relational-api",
    "title": "Darkwing",
    "section": "What’s different from DuckDB’s relational api",
    "text": "What’s different from DuckDB’s relational api\n\navoid connection objects",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "tut_lazy.html",
    "href": "tut_lazy.html",
    "title": "Lazy Evaluation Tutorial",
    "section": "",
    "text": "Since darkwing is based on the DuckDB relational API, all expressions are “lazy” in that they defer evaluation until a result or a data preview is requested. This allows us to build up complex data processing pipelines iteratively, but without needing to compute extranous intermediate results. Instead, under the hood, DuckDB will gather the sequence of steps and pass it to a query optimizer, which will apply optimizations like predicate and projection pushdown. The full operation will be executed by DuckDB making full use of all the cores available on your machine, streaming the operations if possible, and even spilling to disk if the operation is too large to fit in memory.\n\nimport darkwing as dw\n\n\nt0 = dw.Table('data/yellow_tripdata_2010-01.parquet')\nt0.columns\n\n['vendor_id',\n 'pickup_datetime',\n 'dropoff_datetime',\n 'passenger_count',\n 'trip_distance',\n 'pickup_longitude',\n 'pickup_latitude',\n 'rate_code',\n 'store_and_fwd_flag',\n 'dropoff_longitude',\n 'dropoff_latitude',\n 'payment_type',\n 'fare_amount',\n 'surcharge',\n 'mta_tax',\n 'tip_amount',\n 'tolls_amount',\n 'total_amount']\n\n\n\ncount_rows = \"select format('{:.2e}', 1.0*count(*)) as num_rows\"\nt0.do(count_rows)\n\n┌──────────┐\n│ num_rows │\n│ varchar  │\n├──────────┤\n│ 1.49e+07 │\n└──────────┘\n\n\nThe following code is executed instantaneously, since no query operations are performed.\n\nt1 = t0.do(\n    'where (pickup_longitude != 0) and (pickup_latitude != 0)',\n    'where total_amount &gt; 0',\n    \n    'select *, h3_latlng_to_cell(pickup_latitude, pickup_longitude, 12) as hexid',\n    'select * replace ( h3_h3_to_string(hexid) as hexid )',\n    'select cast(pickup_datetime as timestamp) as ts, hexid, total_amount as amt',\n)\n\nListing the table as the last expression in a Jupyter notebook makes Jupyter try to represent the table, which triggers DuckDB do either compute the full table, or, in the case that the table has many rows, compute just enough rows to show a preview. In many instances, the preview is faster to compute.\nThe following is still fast, but just a bit slower than the previous cell, since this is where the query associated with the operations above is actually performed.\n\nt1\n\n┌─────────────────────┬─────────────────┬───────────────────┐\n│         ts          │      hexid      │        amt        │\n│      timestamp      │     varchar     │      double       │\n├─────────────────────┼─────────────────┼───────────────────┤\n│ 2010-01-26 07:41:00 │ 8c2a100d45b01ff │               5.0 │\n│ 2010-01-30 23:31:00 │ 8c2a107258e61ff │              16.3 │\n│ 2010-01-18 20:22:20 │ 8c2a1008b82b5ff │              12.7 │\n│ 2010-01-09 01:18:00 │ 8c2a100d65653ff │              14.3 │\n│ 2010-01-18 19:10:14 │ 8c2a100d22945ff │              6.67 │\n│ 2010-01-17 09:18:00 │ 8c2a10725ac5bff │               6.6 │\n│ 2010-01-09 13:49:00 │ 8c2a100d620b7ff │               7.4 │\n│ 2010-01-09 00:25:00 │ 8c2a1072c86abff │              12.3 │\n│ 2010-01-27 18:15:00 │ 8c2a100d2bb69ff │              12.0 │\n│ 2010-01-08 16:05:00 │ 8c2a107250403ff │              10.2 │\n│          ·          │        ·        │                ·  │\n│          ·          │        ·        │                ·  │\n│          ·          │        ·        │                ·  │\n│ 2010-01-05 16:50:04 │ 8c2a100d2ac47ff │               6.0 │\n│ 2010-01-03 01:30:26 │ 8c2a100d63201ff │               8.3 │\n│ 2010-01-26 18:10:00 │ 8c2a100d60839ff │              13.8 │\n│ 2010-01-26 20:23:00 │ 8c2a1072c9533ff │              15.5 │\n│ 2010-01-07 19:25:00 │ 8c2a100d654c7ff │               6.8 │\n│ 2010-01-03 19:00:53 │ 8c2a1008b368dff │ 8.199999999999998 │\n│ 2010-01-28 14:10:00 │ 8c2a100d666e9ff │               6.4 │\n│ 2010-01-23 15:52:00 │ 8c2a1008bad2bff │             30.79 │\n│ 2010-01-27 15:32:00 │ 8c2a100d2280bff │             55.07 │\n│ 2010-01-01 02:58:00 │ 8c2a100d2aaa9ff │               7.9 │\n├─────────────────────┴─────────────────┴───────────────────┤\n│ ? rows (&gt;9999 rows, 20 shown)                   3 columns │\n└───────────────────────────────────────────────────────────┘\n\n\n\nt2 = t1.alias('tbl1').do(\"\"\"\nselect\n      a.hexid\n    , a.ts as ts1\n    , b.ts as ts2\n    , a.amt as amt1\n    , b.amt as amt2\nfrom\n    tbl1 as a\ninner join\n    tbl1 as b\nusing\n    (hexid)\n\"\"\")\n\nEven though the computation for t2 is complex, we can compute a preview fairly quickly. The following runs in about 2 seconds on my laptop.\n\nt2\n\n┌─────────────────┬─────────────────────┬─────────────────────┬───────────────────┬───────────────────┐\n│      hexid      │         ts1         │         ts2         │       amt1        │       amt2        │\n│     varchar     │      timestamp      │      timestamp      │      double       │      double       │\n├─────────────────┼─────────────────────┼─────────────────────┼───────────────────┼───────────────────┤\n│ 8c2a1008b0231ff │ 2010-01-02 13:28:13 │ 2010-01-20 19:18:00 │               7.2 │               4.8 │\n│ 8c2a100d6c999ff │ 2010-01-02 11:48:34 │ 2010-01-20 23:45:41 │               5.4 │               7.5 │\n│ 8c2a100888e3dff │ 2010-01-10 14:49:00 │ 2010-01-21 20:44:00 │               5.4 │               5.9 │\n│ 8c2a1008bb9b1ff │ 2010-01-08 14:46:12 │ 2010-01-08 07:46:27 │              19.4 │               7.8 │\n│ 8c2a103b0374dff │ 2010-01-08 16:03:15 │ 2010-01-14 17:30:53 │              51.0 │              28.4 │\n│ 8c2a100892491ff │ 2010-01-06 18:56:38 │ 2010-01-26 12:15:00 │              13.2 │               7.0 │\n│ 8c2a107218303ff │ 2010-01-23 19:23:39 │ 2010-01-28 22:21:11 │              11.7 │               7.9 │\n│ 8c2a100d65449ff │ 2010-01-07 21:26:16 │ 2010-01-28 21:20:00 │ 8.099999999999998 │              33.5 │\n│ 8c2a100decaa1ff │ 2010-01-30 04:17:36 │ 2010-01-16 16:48:35 │               6.7 │              13.4 │\n│ 8c2a100d66d61ff │ 2010-01-26 17:58:09 │ 2010-01-19 19:33:00 │               6.0 │               7.4 │\n│        ·        │          ·          │          ·          │                ·  │                ·  │\n│        ·        │          ·          │          ·          │                ·  │                ·  │\n│        ·        │          ·          │          ·          │                ·  │                ·  │\n│ 8c2a100d61091ff │ 2010-01-16 11:24:48 │ 2010-01-06 16:23:00 │              16.6 │ 7.599999999999999 │\n│ 8c2a100e25111ff │ 2010-01-10 14:10:00 │ 2010-01-25 19:44:00 │              32.5 │             42.14 │\n│ 8c2a100d4c901ff │ 2010-01-16 11:13:00 │ 2010-01-13 10:50:00 │               7.2 │              11.4 │\n│ 8c2a100898cc3ff │ 2010-01-22 20:42:00 │ 2010-01-08 07:33:00 │              10.3 │               9.8 │\n│ 8c2a1008ba33dff │ 2010-01-11 23:40:32 │ 2010-01-30 16:44:00 │               5.9 │               5.8 │\n│ 8c2a100d20ed7ff │ 2010-01-06 19:25:00 │ 2010-01-28 23:07:00 │              10.8 │               9.9 │\n│ 8c2a100d216cbff │ 2010-01-31 01:11:00 │ 2010-01-29 23:08:55 │               4.3 │               5.9 │\n│ 8c2a107219747ff │ 2010-01-28 07:56:00 │ 2010-01-31 16:11:00 │              11.0 │ 8.199999999999998 │\n│ 8c2a100d6305bff │ 2010-01-30 15:38:00 │ 2010-01-24 15:50:00 │               9.4 │               5.4 │\n│ 8c2a100d29261ff │ 2010-01-18 13:12:00 │ 2010-01-04 16:38:00 │               4.2 │              10.4 │\n├─────────────────┴─────────────────────┴─────────────────────┴───────────────────┴───────────────────┤\n│ ? rows (&gt;9999 rows, 20 shown)                                                             5 columns │\n└─────────────────────────────────────────────────────────────────────────────────────────────────────┘\n\n\nHowever, running count_rows on t2 forces the full join operation to be performed (previously, we only computed a partial join to dispaly the preview). The following takes about 50 seconds on my laptop.\nNote that the row count for this intermediate table is about 10 billion rows. We deal with the table directly here for demonstration purposes, but we as we continue the pipeline below, we will avoid ever forming this intermediate table.\n\n# renders slowly because you have to do the full join\nt2.do(count_rows)\n\n┌──────────┐\n│ num_rows │\n│ varchar  │\n├──────────┤\n│ 1.05e+10 │\n└──────────┘\n\n\nAgain, it is intantaneous to form the expression representing t3, as long as we don’t need to compute the expression just yet.\nNote that the timestamp filtering below could have also been given above as part of the join. We’re free to do it either way and the performance will be identical because DuckDB will push the filters down in its query planning/optimization step.\n\nt3 = t2.do(\n    'where ts1 &lt; ts2',\n    'where ts2 &lt; ts1 + interval 1 minute',\n    'select hexid, max(abs(amt1-amt2)) as diff group by 1',\n    'where diff &gt; 0'\n    'order by diff',\n)\n\nNote that this is faster than the t2.do(count_rows), even though it does more work! This cell runs in about 44 seconds on my laptop.\nThis final result has about 29 thousand rows, something much more reasonable to materialize directly as a Pandas dataframe, for instance.\n\nt3.do(count_rows)\n\n┌──────────┐\n│ num_rows │\n│ varchar  │\n├──────────┤\n│ 2.86e+04 │\n└──────────┘\n\n\nGet a Pandas dataframe in about 53 seconds.\n\nt3.df()\n\n\n\n\n\n\n\n\nhexid\ndiff\n\n\n\n\n0\n8c2a100d2d12bff\n0.01\n\n\n1\n8c2a100d2a94dff\n0.02\n\n\n2\n8c2a1072c846bff\n0.02\n\n\n3\n8c2a107253359ff\n0.02\n\n\n4\n8c2a100891611ff\n0.02\n\n\n...\n...\n...\n\n\n28563\n8c2a10aa2cb13ff\n175.88\n\n\n28564\n8c2a100f52815ff\n180.45\n\n\n28565\n8c2a108f664e7ff\n203.00\n\n\n28566\n8c2a100d676d7ff\n212.37\n\n\n28567\n8c2a10d76aa37ff\n213.57\n\n\n\n\n28568 rows × 2 columns\n\n\n\n\n# TODO: get a polars dataframe",
    "crumbs": [
      "Tutorials",
      "Lazy Evaluation"
    ]
  }
]